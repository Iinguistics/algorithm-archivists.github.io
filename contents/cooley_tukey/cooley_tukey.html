
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>FFT Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-bibtex-cite/style.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-api-language-selector/api-language-selector.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../decision_problems/decision_problems.html" />
    
    
    <link rel="prev" href="../graham_scan/graham_scan.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Algorithm Archive
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduction/introduction.html">
            
                <a href="../introduction/introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../how_to_contribute/how_to_contribute.html">
            
                <a href="../how_to_contribute/how_to_contribute.html">
            
                    
                    How To Contribute
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../git_and_version_control/git_and_version_control.html">
            
                <a href="../git_and_version_control/git_and_version_control.html">
            
                    
                    Version Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../data_structures/data_structures.html">
            
                <a href="../data_structures/data_structures.html">
            
                    
                    Data Structures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../stacks_and_queues/stacks_and_queues.html">
            
                <a href="../stacks_and_queues/stacks_and_queues.html">
            
                    
                    Stacks and Queues
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../mathematical_background/mathematical_background.html">
            
                <a href="../mathematical_background/mathematical_background.html">
            
                    
                    Mathematical Background
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../notation/notation.html">
            
                <a href="../notation/notation.html">
            
                    
                    Complexity Notation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../bitlogic/bitlogic.html">
            
                <a href="../bitlogic/bitlogic.html">
            
                    
                    Bit Logic
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../convolutions/convolutions.html">
            
                <a href="../convolutions/convolutions.html">
            
                    
                    Convolutions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../taylor_series_expansion/taylor_series_expansion.html">
            
                <a href="../taylor_series_expansion/taylor_series_expansion.html">
            
                    
                    Taylor Series
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../sorting_and_searching/sorting_and_searching.html">
            
                <a href="../sorting_and_searching/sorting_and_searching.html">
            
                    
                    Sorting and Searching
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../bubble_sort/bubble_sort.html">
            
                <a href="../bubble_sort/bubble_sort.html">
            
                    
                    Bubble Sort
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../bogo_sort/bogo_sort.html">
            
                <a href="../bogo_sort/bogo_sort.html">
            
                    
                    Bogo Sort
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../tree_traversal/tree_traversal.html">
            
                <a href="../tree_traversal/tree_traversal.html">
            
                    
                    Tree Traversal
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../euclidean_algorithm/euclidean_algorithm.html">
            
                <a href="../euclidean_algorithm/euclidean_algorithm.html">
            
                    
                    Euclidean Algorithm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../monte_carlo_integration/monte_carlo_integration.html">
            
                <a href="../monte_carlo_integration/monte_carlo_integration.html">
            
                    
                    Monte Carlo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../matrix_methods/matrix_methods.html">
            
                <a href="../matrix_methods/matrix_methods.html">
            
                    
                    Matrix Methods
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../gaussian_elimination/gaussian_elimination.html">
            
                <a href="../gaussian_elimination/gaussian_elimination.html">
            
                    
                    Gaussian Elimination
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../thomas_algorithm/thomas_algorithm.html">
            
                <a href="../thomas_algorithm/thomas_algorithm.html">
            
                    
                    Thomas Algorithm
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../computational_geometry/computational_geometry.html">
            
                <a href="../computational_geometry/computational_geometry.html">
            
                    
                    Computational Geometry
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../gift_wrapping/gift_wrapping.html">
            
                <a href="../gift_wrapping/gift_wrapping.html">
            
                    
                    Gift Wrapping
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1.1" data-path="../jarvis_march/jarvis_march.html">
            
                <a href="../jarvis_march/jarvis_march.html">
            
                    
                    Jarvis March
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.1.2" data-path="../graham_scan/graham_scan.html">
            
                <a href="../graham_scan/graham_scan.html">
            
                    
                    Graham Scan
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.13" data-path="cooley_tukey.html">
            
                <a href="cooley_tukey.html">
            
                    
                    FFT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="../decision_problems/decision_problems.html">
            
                <a href="../decision_problems/decision_problems.html">
            
                    
                    Decision Problems
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="../stable_marriage_problem/stable_marriage_problem.html">
            
                <a href="../stable_marriage_problem/stable_marriage_problem.html">
            
                    
                    Stable Marriage Problem
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../differential_equations/differential_equations.html">
            
                <a href="../differential_equations/differential_equations.html">
            
                    
                    Differential Equation Solvers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../forward_euler_method/forward_euler_method.html">
            
                <a href="../forward_euler_method/forward_euler_method.html">
            
                    
                    Forward Euler Method
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../physics_solvers/physics_solvers.html">
            
                <a href="../physics_solvers/physics_solvers.html">
            
                    
                    Physics Solvers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../verlet_integration/verlet_integration.html">
            
                <a href="../verlet_integration/verlet_integration.html">
            
                    
                    Verlet Integration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="../quantum_systems/quantum_systems.html">
            
                <a href="../quantum_systems/quantum_systems.html">
            
                    
                    Quantum Systems
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.2.1" data-path="../split-operator_method/split-operator_method.html">
            
                <a href="../split-operator_method/split-operator_method.html">
            
                    
                    Split-Operator Method
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../data_compression/data_compression.html">
            
                <a href="../data_compression/data_compression.html">
            
                    
                    Data Compression
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.17.1" data-path="../huffman_encoding/huffman_encoding.html">
            
                <a href="../huffman_encoding/huffman_encoding.html">
            
                    
                    Huffman Encoding
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../quantum_information/quantum_information.html">
            
                <a href="../quantum_information/quantum_information.html">
            
                    
                    Quantum Information
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >FFT</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="what-makes-a-fourier-transform-fast">What Makes a Fourier Transform Fast?</h2>
<p>If there were ever an algorithm to radically change the landscape of computer science and engineering by making seemingly impossible problems possible, it would be the Fast Fourier Transform (FFT).
On the surface, the algorithm seems like a simple application of recursion, and in principle, that is exactly what it is; however, the Fourier Transform is no ordinary transform -- it allows researchers and engineers to easily bounce back and forth between real space and frequency space and is the heart of many physics and engineering applications.
From calculating superfluid vortex positions to super-resolution imaging, Fourier Transforms lay at the heart of many scientific disciplines and are essential to many algorithms we will cover later in this book.</p>
<p>Simply put, the Fourier Transform is a beautiful application of complex number systems; however, it would rarely be used today if not for the ability to quickly perform the operation with Fast Fourier Transform, first introduced by the great Frederick Gauss in 1805 and later independently discovered by James Cooley and John Tukey in 1965 <a href="#cite-1">[1]</a>.
Gauss (of course) already had too many things named after him and Cooley and Tukey both had cooler names, so the most common algorithm for FFT&apos;s today is known as the Cooley-Tukey algorithm.</p>
<h3 id="what-is-a-fourier-transform">What is a Fourier Transform?</h3>
<p>To an outsider, the Fourier Transform looks like a mathematical mess -- certainly a far cry from the heroic portal between two domains I have depicted it to be; however, like most things, it&apos;s not as bad as it initially appears to be.
So, here it is in all it&apos;s glory!</p>
<p><script type="math/tex; ">F(\xi) = \int_{-\infty} ^\infty f(x) e^{-2 \pi i x \xi} dx</script></p>
<p>and</p>
<p><script type="math/tex; ">f(x) = \int_{-\infty} ^\infty F(\xi) e^{2 \pi i \xi x} d\xi</script></p>
<p>Where <script type="math/tex; ">F(\xi)</script> represents a function in frequency space, <script type="math/tex; ">\xi</script> represents a value in frequency space, <script type="math/tex; ">f(x)</script> represents a function in real space, and <script type="math/tex; ">x</script> represents a value in the real space.
Note here that the only difference between the two exponential terms is a minus sign in the transformation to frequency space.
As I mentioned, this is not intuitive syntax, so please allow me to explain a bit.</p>
<p>Firstly, <strong>what does the Fourier Transform do?</strong></p>
<p>If we take a sum sinusoidal functions (like <script type="math/tex; ">\sin(\omega t)</script> or <script type="math/tex; ">\cos(\omega t)</script>), we might find a complicated mess of waves between <script type="math/tex; ">\pm 1</script>.
Each constituent wave can be described by only one value: <script type="math/tex; ">\omega</script>.
So, instead of representing these curves as seen above, we could instead describe them as peaks in frequency space, as shown below.</p>
<p>
    <img class="center" src="res/FT_example.png" width="500">
</p>

<p>This is what the Fourier Transform does!
After performing the transform, it is now much, much easier to understand precisely which frequencies are in our waveform, which is essential to most areas of signal processing.</p>
<p>Now, how does this relate to the transformations above?
Well, the easiest way is to substitute in the Euler&apos;s formula:</p>
<p><script type="math/tex; ">e^{2 \pi i \theta} = \cos(2 \pi \theta) + i \sin(2 \pi \theta)</script></p>
<p>This clearly turns our function in frequency space into:</p>
<p><script type="math/tex; ">F(\xi) = \int_{-\infty} ^\infty f(x) (\cos(-2 \pi x \xi) + i \sin(-2 \pi x \xi))dx</script></p>
<p>and our function in real space into:</p>
<p><script type="math/tex; ">f(x) = \int_{-\infty} ^\infty F(\xi) (\cos(2 \pi \xi x) + i \sin(2 \pi \xi x)) d\xi</script></p>
<p>Here, the <script type="math/tex; ">\sin</script> and <script type="math/tex; ">\cos</script> functions are clearly written in the formulas, so it looks much friendlier, right?
This means that a point in real space is defined by the integral over all space of it&apos;s corresponding frequency function multiplied by sinusoidal oscillations.</p>
<p>Truth be told, even after seeing this math, I still didn&apos;t understand Fourier Transforms.
Truth be told, I didn&apos;t understand it fully until I discretized real and frequency space to create the Discrete Fourier Transform (DFT), which is the only way to implement Fourier Transforms in code.</p>
<h3 id="what-is-a-discrete-fourier-transform">What is a Discrete Fourier Transform?</h3>
<p>In principle, the Discrete Fourier Transform (DFT) is simply the Fourier transform with summations instead of integrals:</p>
<p><script type="math/tex; ">X_k = \sum_{n=0}^{N-1} x_n \cdot e^{-2 \pi i k n / N}</script></p>
<p>and</p>
<p><script type="math/tex; ">x_n = \frac{1}{N} \sum_{k=0}^{N-1} X_k \cdot e^{2 \pi i k n / N}</script></p>
<p>Where <script type="math/tex; ">X_n</script> and <script type="math/tex; ">x_n</script> are sequences of <script type="math/tex; ">N</script> numbers in frequency and real space, respectively.
In principle, this is no easier to understand than the previous case!
For some reason, though, putting code to this transformation really helped me figure out what was actually going on.</p>
<div class="code-method"><div class="code-method-definition"></div><div class="code-method-code"><div class="code-method-sample" data-lang="jl" data-name="Julia"><pre><code class="lang-julia"><span class="hljs-keyword">function</span> DFT(x)
    N = length(x)

    <span class="hljs-comment"># We want two vectors here for real space (n) and frequency space (k)</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    k = n&apos;
    transform_matrix = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n*k/N)
    <span class="hljs-keyword">return</span> transform_matrix*x

<span class="hljs-keyword">end</span>
</code></pre>
</div><div class="code-method-sample" data-lang="c" data-name="C"><pre><code class="lang-cpp">void dft(double complex *X, const size_t N) {
    double complex tmp[N];
    for (size_t i = 0; i &lt; N; ++i) {
        tmp[i] = 0;
        for (size_t j = 0; j &lt; N; ++j) {
            tmp[i] += X[j] * cexp(-2.0 * M_PI * I * j * i / N);
        }
    }

    memcpy(X, tmp, N * sizeof(*X));
}
</code></pre>
</div><div class="code-method-sample" data-lang="clj" data-name="Clojure"><pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> dft
  <span class="hljs-string">&quot;take a vector of real numbers and return a vector of frequency
  space&quot;</span>
  [vx]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [len (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> vx)]
     (<span class="hljs-name">matrix-mult</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> len
                 (<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [n (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> len)
                       k (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> len)]
                   <span class="hljs-comment">;; expresion below is</span>
                   <span class="hljs-comment">;; e^(n*k*2*pi*(1/len)*(-i))</span>
                   (<span class="hljs-name">c/exp</span> (<span class="hljs-name">c/*</span> n k
                               <span class="hljs-number">2</span> Math/PI
                               (/ len)
                               (<span class="hljs-name">c/complex</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span>)))))
      vx)))
</code></pre>
</div><div class="code-method-sample" data-lang="cpp" data-name="C++"><pre><code class="lang-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Iter X, Iter last)</span> </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> N = last - X;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">complex</span>&gt; tmp(N);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j) {
      tmp[i] += X[j] * <span class="hljs-built_in">exp</span>(<span class="hljs-keyword">complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-2.0</span> * M_PI * i * j / N));
    }
  }
  <span class="hljs-built_in">std</span>::copy(<span class="hljs-built_in">std</span>::begin(tmp), <span class="hljs-built_in">std</span>::end(tmp), X);
}
</code></pre>
</div><div class="code-method-sample" data-lang="hs" data-name="Haskell"><pre><code class="lang-julia"><span class="hljs-keyword">function</span> DFT(x)
    N = length(x)

    <span class="hljs-comment"># We want two vectors here for real space (n) and frequency space (k)</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    k = n&apos;
    transform_matrix = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n*k/N)
    <span class="hljs-keyword">return</span> transform_matrix*x

<span class="hljs-keyword">end</span>
</code></pre>
</div><div class="code-method-sample" data-lang="py" data-name="Python"><pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dft</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)
    temp = [<span class="hljs-number">0</span>]*N
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(N):
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(N):
            temp[i] += X[k] * exp(<span class="hljs-number">-2.0j</span>*pi*i*k/N)
    <span class="hljs-keyword">return</span> temp
</code></pre>
</div><div class="code-method-sample" data-lang="scratch" data-name="Scratch"><pre><code class="lang-julia"><span class="hljs-keyword">function</span> DFT(x)
    N = length(x)

    <span class="hljs-comment"># We want two vectors here for real space (n) and frequency space (k)</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    k = n&apos;
    transform_matrix = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n*k/N)
    <span class="hljs-keyword">return</span> transform_matrix*x

<span class="hljs-keyword">end</span>
</code></pre>
</div></div></div>

<p>In this function, we define <code>n</code> to be a set of integers from <script type="math/tex; ">0 \rightarrow N-1</script> and arrange them to be a column.
We then set <code>k</code> to be the same thing, but in a row.
This means that when we multiply them together, we get a matrix, but not just any matrix!
This matrix is the heart to the transformation itself!</p>
<pre><code>M = [1.0+0.0im  1.0+0.0im           1.0+0.0im          1.0+0.0im;
     1.0+0.0im  6.12323e-17-1.0im  -1.0-1.22465e-16im -1.83697e-16+1.0im;
     1.0+0.0im -1.0-1.22465e-16im   1.0+2.44929e-16im -1.0-3.67394e-16im;
     1.0+0.0im -1.83697e-16+1.0im  -1.0-3.67394e-16im  5.51091e-16-1.0im]
</code></pre><p>It was amazing to me when I saw the transform for what it truly was: an actual transformation matrix!
That said, the Discrete Fourier Transform is slow -- primarily because matrix multiplication is slow, and as mentioned before, slow code is not particularly useful.
So what was the trick that everyone used to go from a Discrete Fourier Transform to a <em>Fast</em> Fourier Transform?</p>
<p>Recursion!</p>
<h3 id="the-cooley-tukey-algorithm">The Cooley-Tukey Algorithm</h3>
<p>The problem with using a standard DFT is that it requires a large matrix multiplications and sums over all elements, which are prohibitively complex operations.
The Cooley-Tukey algorithm calculates the DFT directly with fewer summations and without matrix multiplications.
If necessary, DFT&apos;s can still be calculated directly at the early stages of the FFT calculation.
The trick to the Cooley-Tukey algorithm is recursion.
In particular, we split the matrix we wish to perform the FFT on into two parts: one for all elements with even indices and another for all odd indices.
We then proceed to split the array again and again until we have a manageable array size to perform a DFT (or similar FFT) on.
We can also perform a similar re-ordering by using a bit reversal scheme, where we output each array index&apos;s integer value in binary and flip it to find the new location of that element.
With recursion, we can reduce the complexity to <script type="math/tex; ">\sim \mathcal{O}(n \log n)</script>, which is a feasible operation.</p>
<p>In the end, the code looks like:</p>
<div class="code-method"><div class="code-method-definition"></div><div class="code-method-code"><div class="code-method-sample" data-lang="jl" data-name="Julia"><pre><code class="lang-julia"><span class="hljs-keyword">function</span> cooley_tukey(x)
    N = length(x)

    <span class="hljs-keyword">if</span> (N &gt; <span class="hljs-number">2</span>)
        x_odd = cooley_tukey(x[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:N])
        x_even = cooley_tukey(x[<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:N])
    <span class="hljs-keyword">else</span>
        x_odd = x[<span class="hljs-number">1</span>]
        x_even = x[<span class="hljs-number">2</span>]
    <span class="hljs-keyword">end</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    half = div(N,<span class="hljs-number">2</span>)
    factor = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n/N)
    <span class="hljs-keyword">return</span> vcat(x_odd .+ x_even .* factor[<span class="hljs-number">1</span>:half],
                x_odd .- x_even .* factor[<span class="hljs-number">1</span>:half])

<span class="hljs-keyword">end</span>
</code></pre>
</div><div class="code-method-sample" data-lang="c" data-name="C"><pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cooley_tukey</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-keyword">complex</span> *X, <span class="hljs-keyword">const</span> size_t N)</span> </span>{
    <span class="hljs-keyword">if</span> (N &gt;= <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">double</span> <span class="hljs-keyword">complex</span> tmp [N / <span class="hljs-number">2</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N / <span class="hljs-number">2</span>; ++i) {
            tmp[i] = X[<span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>];
            X[i] = X[<span class="hljs-number">2</span>*i];
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N / <span class="hljs-number">2</span>; ++i) {
            X[i + N / <span class="hljs-number">2</span>] = tmp[i];
        }

        cooley_tukey(X, N / <span class="hljs-number">2</span>);
        cooley_tukey(X + N / <span class="hljs-number">2</span>, N / <span class="hljs-number">2</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N / <span class="hljs-number">2</span>; ++i) {
            X[i + N / <span class="hljs-number">2</span>] = X[i] - cexp(<span class="hljs-number">-2.0</span> * I * M_PI * i / N) * X[i + N / <span class="hljs-number">2</span>];
            X[i] -= (X[i + N / <span class="hljs-number">2</span>]-X[i]);
        }
    }
}
</code></pre>
</div><div class="code-method-sample" data-lang="clj" data-name="Clojure"><pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fft [vx]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [len (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> vx)]
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> len <span class="hljs-number">1</span>)
      vx
      <span class="hljs-comment">;;else</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [<span class="hljs-comment">;; take values of vx in the even indices</span>
            even-indices (<span class="hljs-name">keep-indexed</span> #(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">even?</span></span> %<span class="hljs-number">1</span>) %<span class="hljs-number">2</span>) vx)
            <span class="hljs-comment">;; take values in the odd indices</span>
            odd-indices (<span class="hljs-name">keep-indexed</span> #(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> %<span class="hljs-number">1</span>) %<span class="hljs-number">2</span>) vx)
            <span class="hljs-comment">;; recursion</span>
            even-fft (<span class="hljs-name">fft</span> even-indices)
            odd-fft (<span class="hljs-name">fft</span> odd-indices)
            <span class="hljs-comment">;; make a sequence of e^(-2pi*i*k/N) where N is the length</span>
            <span class="hljs-comment">;; vx and k range from 0 to N/2</span>
            omegas-half (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span>
                         (<span class="hljs-name"><span class="hljs-builtin-name">comp</span></span> c/exp
                               (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> c/*
                                        (/ len)
                                        <span class="hljs-number">2</span> Math/PI
                                        (<span class="hljs-name">c/complex</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span>)))
                         (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">0</span> (<span class="hljs-name"><span class="hljs-builtin-name">quot</span></span> len <span class="hljs-number">2</span>)))
            <span class="hljs-comment">;; take the negative of the first sequence because</span>
            <span class="hljs-comment">;; e^(-2pi*i*(k+N/2)/N=-e^(-2pi*i*k/N) where k ranges from</span>
            <span class="hljs-comment">;; 0 to N/2 </span>
            omegas-2half (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> c/- omegas-half)
            mult-add (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> map #(<span class="hljs-name">c/+</span> %<span class="hljs-number">3</span> (<span class="hljs-name">c/*</span> %<span class="hljs-number">1</span> %<span class="hljs-number">2</span>)))]
        (<span class="hljs-name"><span class="hljs-builtin-name">concat</span></span> (<span class="hljs-name">mult-add</span> omegas-half odd-fft even-fft)
                (<span class="hljs-name">mult-add</span> omegas-2half odd-fft even-fft))))))
</code></pre>
</div><div class="code-method-sample" data-lang="cpp" data-name="C++"><pre><code class="lang-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cooley_tukey</span><span class="hljs-params">(Iter first, Iter last)</span> </span>{
  <span class="hljs-keyword">auto</span> size = last - first;
  <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">2</span>) {
    <span class="hljs-comment">// split the range, with even indices going in the first half,</span>
    <span class="hljs-comment">// and odd indices going in the last half.</span>
    <span class="hljs-keyword">auto</span> temp = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">complex</span>&gt;(size / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size / <span class="hljs-number">2</span>; ++i) {
      temp[i] = first[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
      first[i] = first[i * <span class="hljs-number">2</span>];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size / <span class="hljs-number">2</span>; ++i) {
      first[i + size / <span class="hljs-number">2</span>] = temp[i];
    }

    <span class="hljs-comment">// recurse the splits and butterflies in each half of the range</span>
    <span class="hljs-keyword">auto</span> split = first + size / <span class="hljs-number">2</span>;
    cooley_tukey(first, split);
    cooley_tukey(split, last);

    <span class="hljs-comment">// now combine each of those halves with the butterflies</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; size / <span class="hljs-number">2</span>; ++k) {
      <span class="hljs-keyword">auto</span> w = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">exp</span>(<span class="hljs-keyword">complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-2.0</span> * pi * k / size));

      <span class="hljs-keyword">auto</span>&amp; bottom = first[k];
      <span class="hljs-keyword">auto</span>&amp; top = first[k + size / <span class="hljs-number">2</span>];
      top = bottom - w * top;
      bottom -= top - bottom;
    }
  }
}
</code></pre>
</div><div class="code-method-sample" data-lang="hs" data-name="Haskell"><pre><code class="lang-haskell"><span class="hljs-title">fft</span> :: [<span class="hljs-type">Complex</span> <span class="hljs-type">Double</span>] -&gt; [<span class="hljs-type">Complex</span> <span class="hljs-type">Double</span>]
<span class="hljs-title">fft</span> x = <span class="hljs-keyword">let</span> n = length x
            i = <span class="hljs-number">0</span> :+ <span class="hljs-number">1</span>
            w = <span class="hljs-type">M</span>.fromList [(k%n, exp ((<span class="hljs-number">-2</span>)*pi*i*(fromIntegral k)/(fromIntegral n)) ) | k&lt;-[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>]]
            arr = fft&apos; n w (listArray (<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) x)
        <span class="hljs-keyword">in</span> [arr!k | k&lt;-[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>]]
  <span class="hljs-keyword">where</span>
  fft&apos; <span class="hljs-number">1</span> _ x = x
  fft&apos; n w x = <span class="hljs-keyword">let</span> n2 = div n <span class="hljs-number">2</span>
                   e = fft&apos; n2 w (listArray (<span class="hljs-number">0</span>, n2<span class="hljs-number">-1</span>) [x!k | k&lt;-[<span class="hljs-number">0</span>,<span class="hljs-number">2.</span>.n<span class="hljs-number">-1</span>]])
                   o = fft&apos; n2 w (listArray (<span class="hljs-number">0</span>, n2<span class="hljs-number">-1</span>) [x!k | k&lt;-[<span class="hljs-number">1</span>,<span class="hljs-number">3.</span>.n<span class="hljs-number">-1</span>]])
               <span class="hljs-keyword">in</span> array (<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) $ concat [[(k, e!k + o!k * w <span class="hljs-type">M</span>.!(k%n)),
                                            (k + n2, e!k - o!k * w <span class="hljs-type">M</span>.!(k%n))]
                                                               | k &lt;- [<span class="hljs-number">0.</span>.n2<span class="hljs-number">-1</span>]]
</code></pre>
</div><div class="code-method-sample" data-lang="py" data-name="Python"><pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cooley_tukey</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)
    <span class="hljs-keyword">if</span> N &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> X
    even = cooley_tukey(X[<span class="hljs-number">0</span>::<span class="hljs-number">2</span>])
    odd =  cooley_tukey(X[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])

    temp = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(N)]
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(N//<span class="hljs-number">2</span>):
        temp[k] = even[k] + exp(<span class="hljs-number">-2j</span>*pi*k/N) * odd[k]
        temp[k+N//<span class="hljs-number">2</span>] = even[k] - exp(<span class="hljs-number">-2j</span>*pi*k/N)*odd[k]
    <span class="hljs-keyword">return</span> temp
</code></pre>
</div><div class="code-method-sample" data-lang="scratch" data-name="Scratch"><pre><code class="lang-julia"><span class="hljs-keyword">function</span> cooley_tukey(x)
    N = length(x)

    <span class="hljs-keyword">if</span> (N &gt; <span class="hljs-number">2</span>)
        x_odd = cooley_tukey(x[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:N])
        x_even = cooley_tukey(x[<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:N])
    <span class="hljs-keyword">else</span>
        x_odd = x[<span class="hljs-number">1</span>]
        x_even = x[<span class="hljs-number">2</span>]
    <span class="hljs-keyword">end</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    half = div(N,<span class="hljs-number">2</span>)
    factor = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n/N)
    <span class="hljs-keyword">return</span> vcat(x_odd .+ x_even .* factor[<span class="hljs-number">1</span>:half],
                x_odd .- x_even .* factor[<span class="hljs-number">1</span>:half])

<span class="hljs-keyword">end</span>
</code></pre>
</div></div></div>

<p>As a side note, we are enforcing that the array must be a power of 2 for the operation to work.
This is a limitation of the fact that we are using recursion and dividing the array in 2 every time; however, if your array is not a power of 2, you can simply pad the leftover space with 0&apos;s until your array is a power of 2.</p>
<p>The above method is a perfectly valid FFT; however, it is missing the pictorial heart and soul of the Cooley-Tukey algorithm: Butterfly Diagrams.</p>
<h3 id="butterfly-diagrams">Butterfly Diagrams</h3>
<p>Butterfly Diagrams show where each element in the array goes before, during, and after the FFT.
As mentioned, the FFT must perform a DFT.
This means that even though we need to be careful about how we add elements together, we are still ultimately performing the following operation:</p>
<p><script type="math/tex; ">X_k = \sum_{n=0}^{N-1} x_n \cdot e^{-2 \pi i k n / N}</script></p>
<p>However, after shuffling the initial array (by bit reversing or recursive subdivision), we perform the matrix multiplication of the <script type="math/tex; ">e^{-2 \pi k n / N}</script> terms in pieces.
Basically, we split the array into a series of omega values:</p>
<p><script type="math/tex; ">\omega_N^k = e^{-2 \pi i k / N}</script></p>
<p>And at each step, we use the appropriate term.
For example, imagine we need to perform an FFT of an array of only 2 elements.
We can represent this addition with the following (radix-2) butterfly:</p>
<p>
    <img class="center" src="res/radix-2screen_positive.jpg" width="400">
</p>

<p>Here, the diagram means the following:</p>
<p><script type="math/tex; mode=display">
b_0 = a_0 + \omega_2^0 a_1 \\

b_1 = a_0 + \omega_2^1 a_1
</script></p>
<p>However, it turns out that the second half of our array of <script type="math/tex; ">\omega</script> values is always the negative of the first half, so <script type="math/tex; ">\omega_2^0 = -\omega_2^1</script>, so we can use the following butterfly diagram:</p>
<p>
    <img class="center" src="res/radix-2screen.jpg" width="400">
</p>

<p>With the following equations:</p>
<p><script type="math/tex; mode=display">
b_0 = a_0 + \omega_2^0 a_1 \\

b_1 = a_0 - \omega_2^0 a_1
</script></p>
<p>By swapping out the second <script type="math/tex; ">\omega</script> value in this way, we can save a good amount of space.
Now imagine we need to combine more elements.
In this case, we start with simple butterflies, as shown above, and then sum butterflies of butterflies.
For example, if we have 8 elements, this might look like this:</p>
<p>
    <img class="center" src="res/radix-8screen.jpg" width="500">
</p>

<p>Note that we can perform a DFT directly before using any butterflies, if we so desire, but we need to be careful with how we shuffle our array if that&apos;s the case.
In the code snippet provided in the previous section, the subdivision was performed in the same function as the concatenation, so the ordering was always correct; however, if we were to re-order with bit-reversal, this might not be the case.</p>
<p>For example, take a look at the ordering of FFT (<a href="https://en.wikipedia.org/wiki/Butterfly_diagram" target="_blank">found on wikipedia</a>) that performs the DFT shortcut:</p>
<p>
    <img class="center" src="res/butterfly_diagram.png" width="600">
</p>

<p>Here, the ordering of the array was simply divided into even and odd elements once, but they did not recursively divide the arrays of even and odd elements again because they knew they would perform a DFT soon thereafter.</p>
<p>Ultimately, that&apos;s all I want to say about Fourier Transforms for now, but this chapter still needs a good amount of work!
I&apos;ll definitely come back to this at some point, so let me know what you liked and didn&apos;t like and we can go from there!</p>
<h3 id="bibliography">Bibliography</h3>
<p><table class="references"><tr><td><span class="citation-number" id="cite-1">1</span></td><td>Cooley, James W and Tukey, John W, An algorithm for the machine calculation of complex Fourier series, <i>JSTOR</i>, 1965.</td></tr></table></p>
<h2 id="example-code">Example Code</h2>
<p>To be clear, the example code this time will be complicated and requires the following functions:</p>
<ul>
<li>An FFT library (either in-built or something like FFTW)</li>
<li>An approximation function to tell if two arrays are similar</li>
</ul>
<p>As mentioned in the text, the Cooley-Tukey algorithm may be implemented either recursively or non-recursively, with the recursive method being much easier to implement.
I would ask that you implement either the recursive or non-recursive methods (or both, if you feel so inclined).
If the language you want to write your implementation in is already used, please append your code to the already existing codebase.
As before, pull requests are favoured.</p>
<p>Note: I implemented this in Julia because the code seems more straightforward in Julia; however, if you wish to write better Julia code or better code in your own language, please feel free to do so!
<strong>I do not claim that this is the most efficient way to implement the Cooley-Tukey method, so if you have a better way to do it, feel free to implement it that way!</strong></p>
<div class="code-method"><div class="code-method-definition"></div><div class="code-method-code"><div class="code-method-sample" data-lang="jl" data-name="Julia"><pre><code class="lang-julia"><span class="hljs-keyword">using</span> FFTW

<span class="hljs-comment">#simple DFT function</span>
<span class="hljs-keyword">function</span> DFT(x)
    N = length(x)

    <span class="hljs-comment"># We want two vectors here for real space (n) and frequency space (k)</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    k = n&apos;
    transform_matrix = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n*k/N)
    <span class="hljs-keyword">return</span> transform_matrix*x

<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Implementing the Cooley-Tukey Algorithm</span>
<span class="hljs-keyword">function</span> cooley_tukey(x)
    N = length(x)

    <span class="hljs-keyword">if</span> (N &gt; <span class="hljs-number">2</span>)
        x_odd = cooley_tukey(x[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:N])
        x_even = cooley_tukey(x[<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:N])
    <span class="hljs-keyword">else</span>
        x_odd = x[<span class="hljs-number">1</span>]
        x_even = x[<span class="hljs-number">2</span>]
    <span class="hljs-keyword">end</span>
    n = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>
    half = div(N,<span class="hljs-number">2</span>)
    factor = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n/N)
    <span class="hljs-keyword">return</span> vcat(x_odd .+ x_even .* factor[<span class="hljs-number">1</span>:half],
                x_odd .- x_even .* factor[<span class="hljs-number">1</span>:half])

<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> bitreverse(a<span class="hljs-type">::</span><span class="hljs-built_in">Array</span>)
    <span class="hljs-comment"># First, we need to find the necessary number of bits</span>
    digits = convert(<span class="hljs-built_in">Int</span>,ceil(log2(length(a))))

    indices = [i <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>:length(a)-<span class="hljs-number">1</span>]

    bit_indices = []
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(indices)
        push!(bit_indices, bitstring(indices[i]))
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Now stripping the unnecessary numbers</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(bit_indices)
        bit_indices[i] = bit_indices[i][<span class="hljs-keyword">end</span>-digits:<span class="hljs-keyword">end</span>]
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Flipping the bits</span>
    <span class="hljs-keyword">for</span> i =<span class="hljs-number">1</span>:length(bit_indices)
        bit_indices[i] = reverse(bit_indices[i])
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Replacing indices</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(indices)
        indices[i] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span>:digits
            indices[i] += <span class="hljs-number">2</span>^(j-<span class="hljs-number">1</span>) * parse(<span class="hljs-built_in">Int</span>, string(bit_indices[i][<span class="hljs-keyword">end</span>-j]))
        <span class="hljs-keyword">end</span>
       indices[i] += <span class="hljs-number">1</span>
    <span class="hljs-keyword">end</span>

    b = [float(i) <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(a)]
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(indices)
        b[i] = a[indices[i]]
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> b
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> iterative_cooley_tukey(x)
    N = length(x)
    logN = convert(<span class="hljs-built_in">Int</span>,ceil(log2(length(x))))
    bnum = div(N,<span class="hljs-number">2</span>)
    stride = <span class="hljs-number">0</span>;

    x = bitreverse(x)

    z = [<span class="hljs-built_in">Complex</span>(x[i]) <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(x)]
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:logN
       stride = div(N, bnum)
       <span class="hljs-keyword">for</span> j = <span class="hljs-number">0</span>:bnum-<span class="hljs-number">1</span>
           start_index = j*stride + <span class="hljs-number">1</span>
           y = butterfly(z[start_index:start_index + stride - <span class="hljs-number">1</span>])
           <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:length(y)
               z[start_index+k-<span class="hljs-number">1</span>] = y[k]
           <span class="hljs-keyword">end</span>
       <span class="hljs-keyword">end</span>
       bnum = div(bnum,<span class="hljs-number">2</span>)
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> z
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> butterfly(x)
    N = length(x)
    half = div(N,<span class="hljs-number">2</span>)
    n = [i <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>:N-<span class="hljs-number">1</span>]
    half = div(N,<span class="hljs-number">2</span>)
    factor = exp.(-<span class="hljs-number">2</span><span class="hljs-literal">im</span>*<span class="hljs-literal">pi</span>*n/N)

    y = [<span class="hljs-number">0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(x)]

    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:half
        y[i] = x[i] + x[half+i]*factor[i]
        y[half+i] = x[i] - x[half+i]*factor[i]
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> y
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> approx(x, y)
    val = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:length(x)
        <span class="hljs-keyword">if</span> (abs(x[i]) - abs(y[i]) &gt; <span class="hljs-number">1e-5</span>)
            val = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    println(val)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> main()
    x = rand(<span class="hljs-number">128</span>)
    y = cooley_tukey(x)
    z = iterative_cooley_tukey(x)
    w = fft(x)
    approx(y, w)
    approx(z, w)
<span class="hljs-keyword">end</span>

main()
</code></pre>
</div><div class="code-method-sample" data-lang="c" data-name="C"><pre><code class="lang-cpp">#include &lt;complex.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

void dft(double complex *X, const size_t N) {
    double complex tmp[N];
    for (size_t i = 0; i &lt; N; ++i) {
        tmp[i] = 0;
        for (size_t j = 0; j &lt; N; ++j) {
            tmp[i] += X[j] * cexp(-2.0 * M_PI * I * j * i / N);
        }
    }

    memcpy(X, tmp, N * sizeof(*X));
}

void cooley_tukey(double complex *X, const size_t N) {
    if (N &gt;= 2) {
        double complex tmp [N / 2];
        for (size_t i = 0; i &lt; N / 2; ++i) {
            tmp[i] = X[2*i + 1];
            X[i] = X[2*i];
        }
        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = tmp[i];
        }

        cooley_tukey(X, N / 2);
        cooley_tukey(X + N / 2, N / 2);

        for (size_t i = 0; i &lt; N / 2; ++i) {
            X[i + N / 2] = X[i] - cexp(-2.0 * I * M_PI * i / N) * X[i + N / 2];
            X[i] -= (X[i + N / 2]-X[i]);
        }
    }
}

void bit_reverse(double complex *X, size_t N) {
    for (int i = 0; i &lt; N; ++i) {
        int n = i;
        int a = i;
        int count = (int)log2((double)N) - 1;

        n &gt;&gt;= 1;
        while (n &gt; 0) {
            a = (a &lt;&lt; 1) | (n &amp; 1);
            count--;
            n &gt;&gt;= 1;
        }
        n = (a &lt;&lt; count) &amp; ((1 &lt;&lt; (int)log2((double)N)) - 1);

        if (n &gt; i) {
            double complex tmp = X[i];
            X[i] = X[n];
            X[n] = tmp;
        }
    }
}

void iterative_cooley_tukey(double complex *X, size_t N) {
    bit_reverse(X, N);

    for (int i = 1; i &lt;= log2((double)N); ++i) {
        int stride = pow(2, i);
        double complex w = cexp(-2.0 * I * M_PI / stride);
        for (size_t j = 0; j &lt; N; j += stride) {
            double complex v = 1.0;
            for (size_t k = 0; k &lt; stride / 2; ++k) {
                X[k + j + stride / 2] = X[k + j] - v * X[k + j + stride / 2];
                X[k + j] -= (X[k + j + stride / 2] - X[k + j]);
                v *= w;
            }
        }
    }
}

void approx(double complex *X, double complex *Y, size_t N) {
    for (size_t i = 0; i &lt; N; ++i) {
        printf(&quot;%f\n&quot;, cabs(X[i]) - cabs(Y[i]));
    }
}

int main() {
    srand(time(NULL));
    double complex x[64], y[64], z[64];
    for (size_t i = 0; i &lt; 64; ++i) {
        x[i] = rand() / (double) RAND_MAX;
        y[i] = x[i];
        z[i] = x[i];
    }

    cooley_tukey(y, 64);
    iterative_cooley_tukey(z, 64);

    approx(y, z, 64);

    return 0;
}
</code></pre>
</div><div class="code-method-sample" data-lang="clj" data-name="Clojure"><pre><code class="lang-clojure">(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> fft.core
  (<span class="hljs-symbol">:require</span> [complex.core <span class="hljs-symbol">:as</span> c]))
<span class="hljs-comment">;; complex is a jar for complex numbers</span>
<span class="hljs-comment">;; https://github.com/alanforr/complex</span>
<span class="hljs-comment">;; add [complex &quot;0.1.11&quot;] to :dependencies in your project.clj</span>
<span class="hljs-comment">;; and run lein repl or lein deps in the terminal</span>
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> matrix-mult
  <span class="hljs-string">&quot;take a matrix m and a vector v which length is number of columns
  ,return a vector of applying dot-product between v and each row of
  m. the returned vector&apos;s length is the number of rows of m&quot;</span>
  [m v]
  (<span class="hljs-name"><span class="hljs-builtin-name">mapv</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">comp</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> apply c/+)
              (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> map c/* v))
        m))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> dft
  <span class="hljs-string">&quot;take a vector of real numbers and return a vector of frequency
  space&quot;</span>
  [vx]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [len (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> vx)]
     (<span class="hljs-name">matrix-mult</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">partition</span></span> len
                 (<span class="hljs-name"><span class="hljs-builtin-name">for</span></span> [n (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> len)
                       k (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> len)]
                   <span class="hljs-comment">;; expresion below is</span>
                   <span class="hljs-comment">;; e^(n*k*2*pi*(1/len)*(-i))</span>
                   (<span class="hljs-name">c/exp</span> (<span class="hljs-name">c/*</span> n k
                               <span class="hljs-number">2</span> Math/PI
                               (/ len)
                               (<span class="hljs-name">c/complex</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span>)))))
      vx)))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> fft [vx]
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [len (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> vx)]
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> len <span class="hljs-number">1</span>)
      vx
      <span class="hljs-comment">;;else</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [<span class="hljs-comment">;; take values of vx in the even indices</span>
            even-indices (<span class="hljs-name">keep-indexed</span> #(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">even?</span></span> %<span class="hljs-number">1</span>) %<span class="hljs-number">2</span>) vx)
            <span class="hljs-comment">;; take values in the odd indices</span>
            odd-indices (<span class="hljs-name">keep-indexed</span> #(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> %<span class="hljs-number">1</span>) %<span class="hljs-number">2</span>) vx)
            <span class="hljs-comment">;; recursion</span>
            even-fft (<span class="hljs-name">fft</span> even-indices)
            odd-fft (<span class="hljs-name">fft</span> odd-indices)
            <span class="hljs-comment">;; make a sequence of e^(-2pi*i*k/N) where N is the length</span>
            <span class="hljs-comment">;; vx and k range from 0 to N/2</span>
            omegas-half (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span>
                         (<span class="hljs-name"><span class="hljs-builtin-name">comp</span></span> c/exp
                               (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> c/*
                                        (/ len)
                                        <span class="hljs-number">2</span> Math/PI
                                        (<span class="hljs-name">c/complex</span> <span class="hljs-number">0</span> <span class="hljs-number">-1</span>)))
                         (<span class="hljs-name"><span class="hljs-builtin-name">range</span></span> <span class="hljs-number">0</span> (<span class="hljs-name"><span class="hljs-builtin-name">quot</span></span> len <span class="hljs-number">2</span>)))
            <span class="hljs-comment">;; take the negative of the first sequence because</span>
            <span class="hljs-comment">;; e^(-2pi*i*(k+N/2)/N=-e^(-2pi*i*k/N) where k ranges from</span>
            <span class="hljs-comment">;; 0 to N/2 </span>
            omegas-2half (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> c/- omegas-half)
            mult-add (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> map #(<span class="hljs-name">c/+</span> %<span class="hljs-number">3</span> (<span class="hljs-name">c/*</span> %<span class="hljs-number">1</span> %<span class="hljs-number">2</span>)))]
        (<span class="hljs-name"><span class="hljs-builtin-name">concat</span></span> (<span class="hljs-name">mult-add</span> omegas-half odd-fft even-fft)
                (<span class="hljs-name">mult-add</span> omegas-2half odd-fft even-fft))))))
(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> -main [&amp; args]
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [vx [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]
          len (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> vx)
          <span class="hljs-comment">;; calculate the next power of 2 after len</span>
          <span class="hljs-comment">;; the reason behind this is to fill them with zeros for fft</span>
          next-len (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span>
                    [len <span class="hljs-number">2</span>]
                    (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> #(<span class="hljs-name">Math/log</span> %))
                    (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> /)
                    Math/ceil
                    (<span class="hljs-name">Math/pow</span> <span class="hljs-number">2</span>)
                    int)
          <span class="hljs-comment">;; add zeros at the end of vx</span>
          complete-vx (<span class="hljs-name"><span class="hljs-builtin-name">into</span></span> vx (<span class="hljs-name"><span class="hljs-builtin-name">repeat</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> next-len len) <span class="hljs-number">0</span>))
          fft-cvx (<span class="hljs-name">fft</span> complete-vx)
          dft-cvx (<span class="hljs-name">dft</span> complete-vx)
          diffv (<span class="hljs-name"><span class="hljs-builtin-name">mapv</span></span> c/- fft-cvx dft-cvx)]
    (<span class="hljs-name">println</span> <span class="hljs-string">&quot;vx:&quot;</span> vx)
    (<span class="hljs-name">println</span> <span class="hljs-string">&quot;complete-vx:&quot;</span> complete-vx)
    (<span class="hljs-name">println</span> <span class="hljs-string">&quot;result from fft:&quot;</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> c/stringify fft-cvx))
    (<span class="hljs-name">println</span> <span class="hljs-string">&quot;result from dft:&quot;</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> c/stringify dft-cvx))
    (<span class="hljs-name">println</span> <span class="hljs-string">&quot;difference: &quot;</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> c/stringify diffv))))
</code></pre>
</div><div class="code-method-sample" data-lang="cpp" data-name="C++"><pre><code class="lang-cpp">// written by Gathros, modernized by Nicole Mazzuca.

#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;

// These headers are for presentation not for the algorithm.
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

using std::begin;
using std::end;
using std::swap;

using std::size_t;

using complex = std::complex&lt;double&gt;;
static const double pi = 3.14159265358979323846264338327950288419716;

template &lt;typename Iter&gt;
void dft(Iter X, Iter last) {
  const auto N = last - X;
  std::vector&lt;complex&gt; tmp(N);
  for (auto i = 0; i &lt; N; ++i) {
    for (auto j = 0; j &lt; N; ++j) {
      tmp[i] += X[j] * exp(complex(0, -2.0 * M_PI * i * j / N));
    }
  }
  std::copy(std::begin(tmp), std::end(tmp), X);
}

// `cooley_tukey` does the cooley-tukey algorithm, recursively
template &lt;typename Iter&gt;
void cooley_tukey(Iter first, Iter last) {
  auto size = last - first;
  if (size &gt;= 2) {
    // split the range, with even indices going in the first half,
    // and odd indices going in the last half.
    auto temp = std::vector&lt;complex&gt;(size / 2);
    for (int i = 0; i &lt; size / 2; ++i) {
      temp[i] = first[i * 2 + 1];
      first[i] = first[i * 2];
    }
    for (int i = 0; i &lt; size / 2; ++i) {
      first[i + size / 2] = temp[i];
    }

    // recurse the splits and butterflies in each half of the range
    auto split = first + size / 2;
    cooley_tukey(first, split);
    cooley_tukey(split, last);

    // now combine each of those halves with the butterflies
    for (int k = 0; k &lt; size / 2; ++k) {
      auto w = std::exp(complex(0, -2.0 * pi * k / size));

      auto&amp; bottom = first[k];
      auto&amp; top = first[k + size / 2];
      top = bottom - w * top;
      bottom -= top - bottom;
    }
  }
}

// note: (last - first) must be less than 2**32 - 1
template &lt;typename Iter&gt;
void sort_by_bit_reverse(Iter first, Iter last) {
  // sorts the range [first, last) in bit-reversed order,
  // by the method suggested by the FFT
  auto size = last - first;

  for (std::uint32_t i = 0; i &lt; size; ++i) {
    auto b = i;
    b = (((b &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((b &amp; 0x55555555) &lt;&lt; 1));
    b = (((b &amp; 0xcccccccc) &gt;&gt; 2) | ((b &amp; 0x33333333) &lt;&lt; 2));
    b = (((b &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((b &amp; 0x0f0f0f0f) &lt;&lt; 4));
    b = (((b &amp; 0xff00ff00) &gt;&gt; 8) | ((b &amp; 0x00ff00ff) &lt;&lt; 8));
    b = ((b &gt;&gt; 16) | (b &lt;&lt; 16)) &gt;&gt; (32 - std::uint32_t(log2(size)));
    if (b &gt; i) {
      swap(first[b], first[i]);
    }
  }
}

// `iterative_cooley_tukey` does the cooley-tukey algorithm iteratively
template &lt;typename Iter&gt;
void iterative_cooley_tukey(Iter first, Iter last) {
  sort_by_bit_reverse(first, last);

  // perform the butterfly on the range
  auto size = last - first;
  for (int stride = 2; stride &lt;= size; stride *= 2) {
    auto w = exp(complex(0, -2.0 * pi / stride));
    for (int j = 0; j &lt; size; j += stride) {
      auto v = complex(1.0);
      for (int k = 0; k &lt; stride / 2; k++) {
        first[k + j + stride / 2] =
            first[k + j] - v * first[k + j + stride / 2];
        first[k + j] -= (first[k + j + stride / 2] - first[k + j]);
        v *= w;
      }
    }
  }
}

int main() {
  // initalize the FFT inputs
  std::random_device random_device;
  std::mt19937 rng(random_device());
  std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);

  std::array&lt;complex, 64&gt; initial;
  std::generate(
      begin(initial), end(initial), [&amp;] { return distribution(rng); });

  auto recursive = initial;
  auto iterative = initial;

  // Preform an FFT on the arrays.
  cooley_tukey(begin(recursive), end(recursive));
  iterative_cooley_tukey(begin(iterative), end(iterative));

  // Check if the arrays are approximately equivalent
  std::cout &lt;&lt; std::right &lt;&lt; std::setw(16) &lt;&lt; &quot;idx&quot; &lt;&lt; std::setw(16) &lt;&lt; &quot;rec&quot;
            &lt;&lt; std::setw(16) &lt;&lt; &quot;it&quot; &lt;&lt; std::setw(16) &lt;&lt; &quot;subtracted&quot; &lt;&lt; &apos;\n&apos;;
  for (size_t i = 0; i &lt; initial.size(); ++i) {
    auto rec = recursive[i];
    auto it = iterative[i];
    std::cout &lt;&lt; std::setw(16) &lt;&lt; i &lt;&lt; std::setw(16) &lt;&lt; std::abs(rec)
              &lt;&lt; std::setw(16) &lt;&lt; std::abs(it) &lt;&lt; std::setw(16)
              &lt;&lt; (std::abs(rec) - std::abs(it)) &lt;&lt; &apos;\n&apos;;
  }
}
</code></pre>
</div><div class="code-method-sample" data-lang="hs" data-name="Haskell"><pre><code class="lang-haskell"><span class="hljs-keyword">import</span> Data.Complex
<span class="hljs-keyword">import</span> Data.Array
<span class="hljs-keyword">import</span> Data.Ratio
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> M

<span class="hljs-title">fft</span> :: [<span class="hljs-type">Complex</span> <span class="hljs-type">Double</span>] -&gt; [<span class="hljs-type">Complex</span> <span class="hljs-type">Double</span>]
<span class="hljs-title">fft</span> x = <span class="hljs-keyword">let</span> n = length x
            i = <span class="hljs-number">0</span> :+ <span class="hljs-number">1</span>
            w = <span class="hljs-type">M</span>.fromList [(k%n, exp ((<span class="hljs-number">-2</span>)*pi*i*(fromIntegral k)/(fromIntegral n)) ) | k&lt;-[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>]]
            arr = fft&apos; n w (listArray (<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>) x)
        <span class="hljs-keyword">in</span> [arr!k | k&lt;-[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>]]
  <span class="hljs-keyword">where</span>
  fft&apos; <span class="hljs-number">1</span> _ x = x
  fft&apos; n w x = <span class="hljs-keyword">let</span> n2 = div n <span class="hljs-number">2</span>
                   e = fft&apos; n2 w (listArray (<span class="hljs-number">0</span>, n2<span class="hljs-number">-1</span>) [x!k | k&lt;-[<span class="hljs-number">0</span>,<span class="hljs-number">2.</span>.n<span class="hljs-number">-1</span>]])
                   o = fft&apos; n2 w (listArray (<span class="hljs-number">0</span>, n2<span class="hljs-number">-1</span>) [x!k | k&lt;-[<span class="hljs-number">1</span>,<span class="hljs-number">3.</span>.n<span class="hljs-number">-1</span>]])
               <span class="hljs-keyword">in</span> array (<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) $ concat [[(k, e!k + o!k * w <span class="hljs-type">M</span>.!(k%n)),
                                            (k + n2, e!k - o!k * w <span class="hljs-type">M</span>.!(k%n))]
                                                               | k &lt;- [<span class="hljs-number">0.</span>.n2<span class="hljs-number">-1</span>]]

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  print $ fft [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
</code></pre>
</div><div class="code-method-sample" data-lang="py" data-name="Python"><pre><code class="lang-python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> random
<span class="hljs-keyword">from</span> cmath <span class="hljs-keyword">import</span> exp, pi
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> log2

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dft</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)
    temp = [<span class="hljs-number">0</span>]*N
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(N):
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(N):
            temp[i] += X[k] * exp(<span class="hljs-number">-2.0j</span>*pi*i*k/N)
    <span class="hljs-keyword">return</span> temp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cooley_tukey</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)
    <span class="hljs-keyword">if</span> N &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> X
    even = cooley_tukey(X[<span class="hljs-number">0</span>::<span class="hljs-number">2</span>])
    odd =  cooley_tukey(X[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])

    temp = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(N)]
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(N//<span class="hljs-number">2</span>):
        temp[k] = even[k] + exp(<span class="hljs-number">-2j</span>*pi*k/N) * odd[k]
        temp[k+N//<span class="hljs-number">2</span>] = even[k] - exp(<span class="hljs-number">-2j</span>*pi*k/N)*odd[k]
    <span class="hljs-keyword">return</span> temp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bitReverse</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)
    temp = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(N)]
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(N):
        b =  sum(<span class="hljs-number">1</span>&lt;&lt;(int(log2(N))<span class="hljs-number">-1</span>-i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(int(log2(N))) <span class="hljs-keyword">if</span> k&gt;&gt;i&amp;<span class="hljs-number">1</span>)
        temp[k] = X[b]
        temp[b] = X[k]
    <span class="hljs-keyword">return</span> temp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterative_cooley_tukey</span><span class="hljs-params">(X)</span>:</span>
    N = len(X)

    X = bitReverse(X)

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, int(log2(N)) + <span class="hljs-number">1</span>):
        stride = <span class="hljs-number">2</span>**i
        w = exp(<span class="hljs-number">-2j</span>*pi/stride)
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, N, stride):
            v = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(stride//<span class="hljs-number">2</span>):
                X[k + j + stride//<span class="hljs-number">2</span>] = X[k + j] - v*X[k + j + stride//<span class="hljs-number">2</span>];
                X[k + j] -= (X[k + j + stride//<span class="hljs-number">2</span>] - X[k + j]);
                v *= w;
    <span class="hljs-keyword">return</span> X

X = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):
    X.append(random())

Y = cooley_tukey(X)
Z = iterative_cooley_tukey(X)
T = dft(X)

print(all(abs([Y[i] - Z[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>)][j]) &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>)))
print(all(abs([Y[i] - T[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>)][j]) &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>)))
</code></pre>
</div><div class="code-method-sample" data-lang="scratch" data-name="Scratch"><p>Some rather impressive scratch code was submitted by Jie and can be found here: <a href="https://scratch.mit.edu/projects/37759604/#editor" target="_blank">https://scratch.mit.edu/projects/37759604/#editor</a></p>
</div></div></div>


<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../graham_scan/graham_scan.html" class="navigation navigation-prev " aria-label="Previous page: Graham Scan">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../decision_problems/decision_problems.html" class="navigation navigation-next " aria-label="Next page: Decision Problems">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"FFT","level":"1.13","depth":1,"next":{"title":"Decision Problems","level":"1.14","depth":1,"path":"contents/decision_problems/decision_problems.md","ref":"contents/decision_problems/decision_problems.md","articles":[{"title":"Stable Marriage Problem","level":"1.14.1","depth":2,"path":"contents/stable_marriage_problem/stable_marriage_problem.md","ref":"contents/stable_marriage_problem/stable_marriage_problem.md","articles":[]}]},"previous":{"title":"Graham Scan","level":"1.12.1.2","depth":3,"path":"contents/graham_scan/graham_scan.md","ref":"contents/graham_scan/graham_scan.md","articles":[]},"dir":"ltr"},"config":{"plugins":["fontsettings","mathjax@https://github.com/algorithm-archivists/plugin-mathjax","bibtex-cite","creativecommons","wordcount","api-language-selector@https://github.com/algorithm-archivists/gitbook-plugin-api-language-selector.git","include-codeblock","ga","bulk-redirect"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"api-language-selector":{"languages":[{"lang":"jl","name":"Julia","default":true},{"lang":"cs","name":"C#"},{"lang":"cpp","name":"C++"},{"lang":"c","name":"C"},{"lang":"py","name":"Python"},{"lang":"js","name":"JavaScript"},{"lang":"scratch","name":"Scratch"},{"lang":"hs","name":"Haskell"},{"lang":"rs","name":"Rust"},{"lang":"ml","name":"OCaml"},{"lang":"java","name":"Java"},{"lang":"clj","name":"Clojure"},{"lang":"elm","name":"Elm"},{"lang":"LabVIEW","name":"LabVIEW"},{"lang":"d","name":"D"},{"lang":"go","name":"Go"},{"lang":"swift","name":"Swift"},{"lang":"racket","name":"Racket"},{"lang":"m","name":"Matlab"},{"lang":"r","name":"R"},{"lang":"ti83b","name":"TI-83 Basic"},{"lang":"lua","name":"Lua"},{"lang":"crystal","name":"Crystal"},{"lang":"php","name":"PHP"},{"lang":"lisp","name":"Lisp"},{"lang":"nim","name":"Nim"},{"lang":"asm-x64","name":"X86-64 Assembly"},{"lang":"f90","name":"Fortran90"},{"lang":"scala","name":"Scala"},{"lang":"emojic","name":"Emojicode"}]},"wordcount":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"family":"sans","size":2,"theme":"white"},"highlight":{},"bulk-redirect":{"basepath":"/","redirectsFile":"redirects.json"},"bibtex-cite":{},"creativecommons":{},"mathjax":{"forceSVG":false,"version":"2.6.1"},"ga":{"configuration":"auto","token":"UA-118252470-1"},"include-codeblock":{"check":false,"edit":false,"fixlang":true,"lang":"","template":"default","theme":"chrome","unindent":true},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","lunr":{"maxIndexSize":1000000000},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"bibCount":0,"variables":{},"bib":[{"citationKey":"CT1965","entryType":"ARTICLE","entryTags":{"TITLE":"An algorithm for the machine calculation of complex Fourier series","AUTHOR":"Cooley, James W and Tukey, John W","JOURNAL":"Mathematics of computation","VOLUME":"19","NUMBER":"90","PAGES":"297--301","YEAR":"1965","PUBLISHER":"JSTOR"}},{"citationKey":"JM1973","entryType":"ARTICLE","entryTags":{"TITLE":"On the identification of the convex hull of a finite set of points in the plane","AUTHOR":"Jarvis, Ray A","JOURNAL":"Information processing letters","VOLUME":"2","NUMBER":"1","PAGES":"18--21","YEAR":"1973","PUBLISHER":"Elsevier"}},{"citationKey":"GS1972","entryType":"ARTICLE","entryTags":{"TITLE":"An efficient algorithm for determining the convex hull of a finite planar set","AUTHOR":"Graham, Ronald L","JOURNAL":"Information processing letters","VOLUME":"1","NUMBER":"4","PAGES":"132--133","YEAR":"1972","PUBLISHER":"Elsevier"}}],"gitbook":"3.x.x"},"file":{"path":"contents/cooley_tukey/cooley_tukey.md","mtime":"2018-10-07T09:05:27.205Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-07T09:07:13.055Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-api-language-selector/api-language-selector.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    

    </body>
</html>

