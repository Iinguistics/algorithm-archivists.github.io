
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Huffman Encoding Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-bibtex-cite/style.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-api-language-selector/api-language-selector.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../quantum_information/quantum_information.html" />
    
    
    <link rel="prev" href="../data_compression/data_compression.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Algorithm Archive
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduction/introduction.html">
            
                <a href="../introduction/introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../how_to_contribute/how_to_contribute.html">
            
                <a href="../how_to_contribute/how_to_contribute.html">
            
                    
                    How To Contribute
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../git_and_version_control/git_and_version_control.html">
            
                <a href="../git_and_version_control/git_and_version_control.html">
            
                    
                    Version Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../data_structures/data_structures.html">
            
                <a href="../data_structures/data_structures.html">
            
                    
                    Data Structures
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../stacks_and_queues/stacks_and_queues.html">
            
                <a href="../stacks_and_queues/stacks_and_queues.html">
            
                    
                    Stacks and Queues
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../mathematical_background/mathematical_background.html">
            
                <a href="../mathematical_background/mathematical_background.html">
            
                    
                    Mathematical Background
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../notation/notation.html">
            
                <a href="../notation/notation.html">
            
                    
                    Complexity Notation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../bitlogic/bitlogic.html">
            
                <a href="../bitlogic/bitlogic.html">
            
                    
                    Bit Logic
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../convolutions/convolutions.html">
            
                <a href="../convolutions/convolutions.html">
            
                    
                    Convolutions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../taylor_series_expansion/taylor_series_expansion.html">
            
                <a href="../taylor_series_expansion/taylor_series_expansion.html">
            
                    
                    Taylor Series
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../sorting_and_searching/sorting_and_searching.html">
            
                <a href="../sorting_and_searching/sorting_and_searching.html">
            
                    
                    Sorting and Searching
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../bubble_sort/bubble_sort.html">
            
                <a href="../bubble_sort/bubble_sort.html">
            
                    
                    Bubble Sort
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../bogo_sort/bogo_sort.html">
            
                <a href="../bogo_sort/bogo_sort.html">
            
                    
                    Bogo Sort
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../tree_traversal/tree_traversal.html">
            
                <a href="../tree_traversal/tree_traversal.html">
            
                    
                    Tree Traversal
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../euclidean_algorithm/euclidean_algorithm.html">
            
                <a href="../euclidean_algorithm/euclidean_algorithm.html">
            
                    
                    Euclidean Algorithm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../monte_carlo_integration/monte_carlo_integration.html">
            
                <a href="../monte_carlo_integration/monte_carlo_integration.html">
            
                    
                    Monte Carlo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../matrix_methods/matrix_methods.html">
            
                <a href="../matrix_methods/matrix_methods.html">
            
                    
                    Matrix Methods
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../gaussian_elimination/gaussian_elimination.html">
            
                <a href="../gaussian_elimination/gaussian_elimination.html">
            
                    
                    Gaussian Elimination
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../thomas_algorithm/thomas_algorithm.html">
            
                <a href="../thomas_algorithm/thomas_algorithm.html">
            
                    
                    Thomas Algorithm
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../computational_geometry/computational_geometry.html">
            
                <a href="../computational_geometry/computational_geometry.html">
            
                    
                    Computational Geometry
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../gift_wrapping/gift_wrapping.html">
            
                <a href="../gift_wrapping/gift_wrapping.html">
            
                    
                    Gift Wrapping
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1.1" data-path="../jarvis_march/jarvis_march.html">
            
                <a href="../jarvis_march/jarvis_march.html">
            
                    
                    Jarvis March
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.1.2" data-path="../graham_scan/graham_scan.html">
            
                <a href="../graham_scan/graham_scan.html">
            
                    
                    Graham Scan
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="../cooley_tukey/cooley_tukey.html">
            
                <a href="../cooley_tukey/cooley_tukey.html">
            
                    
                    FFT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="../decision_problems/decision_problems.html">
            
                <a href="../decision_problems/decision_problems.html">
            
                    
                    Decision Problems
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="../stable_marriage_problem/stable_marriage_problem.html">
            
                <a href="../stable_marriage_problem/stable_marriage_problem.html">
            
                    
                    Stable Marriage Problem
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="../differential_equations/differential_equations.html">
            
                <a href="../differential_equations/differential_equations.html">
            
                    
                    Differential Equation Solvers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.15.1" data-path="../forward_euler_method/forward_euler_method.html">
            
                <a href="../forward_euler_method/forward_euler_method.html">
            
                    
                    Forward Euler Method
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="../physics_solvers/physics_solvers.html">
            
                <a href="../physics_solvers/physics_solvers.html">
            
                    
                    Physics Solvers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.1" data-path="../verlet_integration/verlet_integration.html">
            
                <a href="../verlet_integration/verlet_integration.html">
            
                    
                    Verlet Integration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16.2" data-path="../quantum_systems/quantum_systems.html">
            
                <a href="../quantum_systems/quantum_systems.html">
            
                    
                    Quantum Systems
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.16.2.1" data-path="../split-operator_method/split-operator_method.html">
            
                <a href="../split-operator_method/split-operator_method.html">
            
                    
                    Split-Operator Method
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="../data_compression/data_compression.html">
            
                <a href="../data_compression/data_compression.html">
            
                    
                    Data Compression
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.17.1" data-path="huffman_encoding.html">
            
                <a href="huffman_encoding.html">
            
                    
                    Huffman Encoding
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="../quantum_information/quantum_information.html">
            
                <a href="../quantum_information/quantum_information.html">
            
                    
                    Quantum Information
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Huffman Encoding</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="huffman-encoding">Huffman Encoding</h1>
<p>If there were ever a data compression method to take the world by storm, it would be Huffman encoding.
In fact, this was the method that got me into computational methods to begin with.
I distinctly remember sitting in my data compression class and talking about the great information theorist Claude Shannon and Robert Fano, when suddenly my professor introduced a new kid to the mix: David Huffman.
He managed to rip the heart out of the methods described by leaders of the field and create a data compression method that was easier to understand and implement, while also providing more robust results, and apparently this was all done for a school project!</p>
<p>It was in that moment, I knew I would never amount to anything.
I have since accepted that fact and moved on.</p>
<p>Huffman encoding follows from the problem described in the <a href="../data_compression/data_compression.html">Data Compression</a> section.
We have a string that we want to encode into bits.
Huffman encoding ensures that our encoded bitstring is as small as possible without losing any information.
Because it is both lossless and guarantees the smallest possible bit length, it outright replaces both Shannon and Shannon-Fano encoding in most cases, which is a little weird because the method was devised while Huffman was taking a course from Fano, himself!</p>
<p>The idea is somewhat straightforward in principle, but a little difficult to code in practice.
By creating a binary tree of the input alphabet, every branch can be provided a unique bit representation simply by assigning a binary value to each child and reading to a character in a leaf node if starting from the root node.</p>
<p>So now the question is: how do we create a binary tree?
Well, here we build it from the bottom up like so:</p>
<ol>
<li>Order all characters according to the frequency they appear in the input bitstring, with the most frequent character at the top of the list. Be sure to keep track of the frequencies, too!</li>
<li>Add the smallest two values together to create a new node with a new frequency.</li>
<li>Keep doing step 2 until the tree is complete.</li>
<li>Read the tree backwards from the root node and concatenate the final bitstring codeword. Keep all codewords and put them into your final set of codewords (sometimes called a codebook)</li>
<li>Encode your phrase with the codebook.</li>
</ol>
<p>And that&apos;s it.
Here&apos;s an image of what this might look like for the phrase <code>bibbity_bobbity</code>:</p>
<p>
    <img class="center" src="res/huffman_tree.png" width="500">
</p>

<p>This will create a codebook that looks like this:</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Bit Representation</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>b</em></td>
<td>0</td>
</tr>
<tr>
<td><em>i</em></td>
<td>100</td>
</tr>
<tr>
<td><em>t</em></td>
<td>101</td>
</tr>
<tr>
<td><em>y</em></td>
<td>110</td>
</tr>
<tr>
<td><em>o</em></td>
<td>1110</td>
</tr>
<tr>
<td><em>_</em></td>
<td>1111</td>
</tr>
</tbody>
</table>
<p>and <code>bibbity_bobbity</code> becomes <code>01000010010111011110111000100101110</code>.
As mentioned this uses the minimum number of bits possible for encoding.
The fact that this algorithm is both conceptually simple and provably useful is rather extraordinary to me and is why Huffman encoding will always hold a special place in my heart.</p>
<h2 id="example-code">Example Code</h2>
<p>In code, this can be a little tricky. It requires a method to continually sort the nodes as you add more and more nodes to the system.
The most straightforward way to do this in some languages is with a priority queue, but depending on the language, this might be more or less appropriate.
In addition, to read the tree backwards, some sort of <a href="../tree_traversal/tree_traversal.html">Depth First Search</a> needs to be implemented.
Whether you use a stack or straight-up recursion also depends on the language, but the recursive method is a little easier to understand in most cases.</p>
<div class="code-method"><div class="code-method-definition"></div><div class="code-method-code"><div class="code-method-sample" data-lang="jl" data-name="Julia"><pre><code class="lang-julia"><span class="hljs-comment"># This is for the PriorityQueue</span>
<span class="hljs-keyword">using</span> DataStructures

struct Leaf
    weight<span class="hljs-type">::</span><span class="hljs-built_in">Int64</span>
    key<span class="hljs-type">::</span><span class="hljs-built_in">Char</span>
<span class="hljs-keyword">end</span>

struct Branch
    right<span class="hljs-type">::</span><span class="hljs-built_in">Union</span>{Leaf, Branch}
    left<span class="hljs-type">::</span><span class="hljs-built_in">Union</span>{Leaf, Branch}
    weight<span class="hljs-type">::</span><span class="hljs-built_in">Int64</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">const</span> Node = <span class="hljs-built_in">Union</span>{Leaf, Branch}
isbranch(branch<span class="hljs-type">::</span>Branch) = <span class="hljs-literal">true</span>
isbranch(other<span class="hljs-type">::</span>T) where {T} = <span class="hljs-literal">false</span>

<span class="hljs-keyword">function</span> codebook_recurse(leaf<span class="hljs-type">::</span>Leaf, code<span class="hljs-type">::</span><span class="hljs-built_in">String</span>,
                          dict<span class="hljs-type">::</span><span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">String</span>})
    dict[leaf.key] = code
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> codebook_recurse(branch<span class="hljs-type">::</span>Branch, code<span class="hljs-type">::</span><span class="hljs-built_in">String</span>,
                          dict<span class="hljs-type">::</span><span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">String</span>})
    codebook_recurse(branch.left, string(code, <span class="hljs-string">&quot;1&quot;</span>), dict)
    codebook_recurse(branch.right, string(code, <span class="hljs-string">&quot;0&quot;</span>), dict)
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># This will depth-first search through the tree</span>
<span class="hljs-comment"># to create bitstrings for each character.</span>
<span class="hljs-comment"># Note: Any depth-first search method will work</span>
<span class="hljs-comment"># This outputs encoding Dict to be used for encoding</span>
<span class="hljs-keyword">function</span> create_codebook(n<span class="hljs-type">::</span>Node)
    codebook = <span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">String</span>}()
    codebook_recurse(n, <span class="hljs-string">&quot;&quot;</span>, codebook)
    <span class="hljs-keyword">return</span> codebook
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># This outputs huffman tree to generate dictionary for encoding</span>
<span class="hljs-keyword">function</span> create_tree(phrase<span class="hljs-type">::</span><span class="hljs-built_in">String</span>)

    <span class="hljs-comment"># creating weights</span>
    weights = PriorityQueue()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> phrase
        temp_string = string(i)
        <span class="hljs-keyword">if</span> (haskey(weights, temp_string))
            weights[temp_string] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>
            weights[temp_string] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Creating all nodes to iterate through</span>
    nodes = PriorityQueue{Node, <span class="hljs-built_in">Int64</span>}()
    <span class="hljs-keyword">while</span>(length(weights) &gt; <span class="hljs-number">0</span>)
        weight = peek(weights)[<span class="hljs-number">2</span>]
        key = dequeue!(weights)[<span class="hljs-number">1</span>]
        temp_node = Leaf(weight, key)
        enqueue!(nodes, temp_node, weight)
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">while</span>(length(nodes) &gt; <span class="hljs-number">1</span>)
        node1 = dequeue!(nodes)
        node2 = dequeue!(nodes)
        temp_node = Branch(node1, node2, node1.weight + node2.weight)
        enqueue!(nodes, temp_node, temp_node.weight)
    <span class="hljs-keyword">end</span>

    huffman_tree = dequeue!(nodes)
    <span class="hljs-keyword">return</span> huffman_tree

<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> encode(codebook<span class="hljs-type">::</span><span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Char</span>, <span class="hljs-built_in">String</span>}, phrase<span class="hljs-type">::</span><span class="hljs-built_in">String</span>)
    final_bitstring = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> phrase
        final_bitstring = final_bitstring * codebook[i]
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> final_bitstring
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> decode(huffman_tree<span class="hljs-type">::</span>Node, bitstring<span class="hljs-type">::</span><span class="hljs-built_in">String</span>)
    current = huffman_tree
    final_string = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bitstring
        <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&apos;1&apos;</span>)
            current = current.left
        <span class="hljs-keyword">else</span>
            current = current.right
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">if</span> (!isbranch(current))
            final_string = final_string * string(current.key)
            current = huffman_tree
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> final_string
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> two_pass_huffman(phrase<span class="hljs-type">::</span><span class="hljs-built_in">String</span>)
    huffman_tree = create_tree(phrase)
    codebook = create_codebook(huffman_tree)
    println(codebook)
    bitstring = encode(codebook, phrase)
    final_string = decode(huffman_tree, bitstring)
    println(bitstring)
    println(final_string)
<span class="hljs-keyword">end</span>

two_pass_huffman(<span class="hljs-string">&quot;bibbity bobbity&quot;</span>)
</code></pre>
</div><div class="code-method-sample" data-lang="rs" data-name="Rust"><pre><code class="lang-rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> itertools;

<span class="hljs-keyword">use</span> std::cmp::{<span class="hljs-built_in">Ord</span>, Ordering, <span class="hljs-built_in">PartialOrd</span>};
<span class="hljs-keyword">use</span> std::collections::{BinaryHeap, HashMap};

<span class="hljs-keyword">use</span> itertools::Itertools;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">HuffmanTree</span></span> {
    Branch {
        count: <span class="hljs-keyword">i32</span>,
        left: <span class="hljs-built_in">Box</span>&lt;HuffmanTree&gt;,
        right: <span class="hljs-built_in">Box</span>&lt;HuffmanTree&gt;,
    },
    Leaf {
        count: <span class="hljs-keyword">i32</span>,
        value: <span class="hljs-keyword">char</span>,
    },
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">PartialEq</span> <span class="hljs-keyword">for</span> HuffmanTree {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">bool</span> {
        <span class="hljs-keyword">self</span>.count() == other.count()
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Eq</span> <span class="hljs-keyword">for</span> HuffmanTree {}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">PartialOrd</span> <span class="hljs-keyword">for</span> HuffmanTree {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partial_cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt; {
        other.count().partial_cmp(&amp;<span class="hljs-keyword">self</span>.count())
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Ord</span> <span class="hljs-keyword">for</span> HuffmanTree {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; Ordering {
        other.count().cmp(&amp;<span class="hljs-keyword">self</span>.count())
    }
}

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Codebook</span></span> {
    codebook: HashMap&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">String</span>&gt;,
    tree: HuffmanTree,
}

<span class="hljs-keyword">impl</span> HuffmanTree {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(input: &amp;<span class="hljs-keyword">str</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> counts = input.chars().fold(HashMap::new(), |<span class="hljs-keyword">mut</span> map, c| {
            *map.entry(c).or_insert(<span class="hljs-number">0</span>) += <span class="hljs-number">1</span>;
            map
        });
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> queue = counts
            .iter()
            .map(|(&amp;value, &amp;count)| HuffmanTree::Leaf { value, count })
            .collect::&lt;BinaryHeap&lt;HuffmanTree&gt;&gt;();

        <span class="hljs-keyword">while</span> queue.len() &gt; <span class="hljs-number">1</span> {
            <span class="hljs-keyword">let</span> left = queue.pop().unwrap();
            <span class="hljs-keyword">let</span> right = queue.pop().unwrap();
            queue.push(HuffmanTree::Branch {
                count: left.count() + right.count(),
                left: <span class="hljs-built_in">Box</span>::new(left),
                right: <span class="hljs-built_in">Box</span>::new(right),
            })
        }

        queue.pop().expect(<span class="hljs-string">&quot;The Huffman tree has to have a root&quot;</span>)
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">count</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">i32</span> {
        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {
            HuffmanTree::Branch { count, .. } =&gt; count,
            HuffmanTree::Leaf { count, .. } =&gt; count,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">make_codebook</span></span>(<span class="hljs-keyword">self</span>) -&gt; Codebook {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> codebook = HashMap::new();
        <span class="hljs-keyword">self</span>.dfs(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;&quot;</span>), &amp;<span class="hljs-keyword">mut</span> codebook);
        Codebook {
            codebook,
            tree: <span class="hljs-keyword">self</span>,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode</span></span>(&amp;<span class="hljs-keyword">self</span>, input: &amp;<span class="hljs-keyword">str</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> result = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;&quot;</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> !input[start..].is_empty() {
            start += <span class="hljs-keyword">self</span>.decode_dfs(&amp;input[start..], &amp;<span class="hljs-keyword">mut</span> result);
        }
        result
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_dfs</span></span>(&amp;<span class="hljs-keyword">self</span>, input: &amp;<span class="hljs-keyword">str</span>, result: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) -&gt; usize {
        <span class="hljs-keyword">let</span> current = input.chars().next();
        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {
            HuffmanTree::Branch { <span class="hljs-keyword">ref</span> left, .. } <span class="hljs-keyword">if</span> current == <span class="hljs-literal">Some</span>(<span class="hljs-string">&apos;0&apos;</span>) =&gt; {
                <span class="hljs-number">1</span> + left.decode_dfs(&amp;input[<span class="hljs-number">1</span>..], result)
            }
            HuffmanTree::Branch { <span class="hljs-keyword">ref</span> right, .. } <span class="hljs-keyword">if</span> current == <span class="hljs-literal">Some</span>(<span class="hljs-string">&apos;1&apos;</span>) =&gt; {
                <span class="hljs-number">1</span> + right.decode_dfs(&amp;input[<span class="hljs-number">1</span>..], result)
            }
            HuffmanTree::Leaf { value, .. } =&gt; {
                result.push(value);
                <span class="hljs-number">0</span>
            }
            _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unexpected end of input&quot;</span>),
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dfs</span></span>(&amp;<span class="hljs-keyword">self</span>, code: <span class="hljs-built_in">String</span>, codebook: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">String</span>&gt;) {
        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {
            HuffmanTree::Branch {
                <span class="hljs-keyword">ref</span> left,
                <span class="hljs-keyword">ref</span> right,
                ..
            } =&gt; {
                left.dfs(code.clone() + <span class="hljs-string">&quot;0&quot;</span>, codebook);
                right.dfs(code.clone() + <span class="hljs-string">&quot;1&quot;</span>, codebook);
            }
            HuffmanTree::Leaf { value, .. } =&gt; {
                codebook.insert(value, code);
            }
        }
    }
}

<span class="hljs-keyword">impl</span> Codebook {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode</span></span>(&amp;<span class="hljs-keyword">self</span>, input: &amp;<span class="hljs-keyword">str</span>) -&gt; <span class="hljs-built_in">String</span> {
        input.chars().map(|c| &amp;<span class="hljs-keyword">self</span>.codebook[&amp;c]).join(<span class="hljs-string">&quot;&quot;</span>)
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode</span></span>(&amp;<span class="hljs-keyword">self</span>, input: &amp;<span class="hljs-keyword">str</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">self</span>.tree.decode(input)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> input = <span class="hljs-string">&quot;bibbity bobbity&quot;</span>;

    <span class="hljs-keyword">let</span> tree = HuffmanTree::from(input);
    <span class="hljs-keyword">let</span> codebook = tree.make_codebook();
    <span class="hljs-keyword">let</span> encoded = codebook.encode(input);
    <span class="hljs-keyword">let</span> decoded = codebook.decode(&amp;encoded);

    <span class="hljs-comment">// Uncomment this line if you want to see the codebook/tree</span>
    <span class="hljs-comment">// println!(&quot;{:#?}&quot;, codebook);</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, encoded);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, decoded);
}
</code></pre>
</div><div class="code-method-sample" data-lang="c" data-name="C"><pre><code class="lang-cpp">// Made by Guston and edited by Gathros
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

struct tree {
    struct tree* left;
    struct tree* right;

    int count;
    char value;
};

struct bitstring_builder {
    char str[257];
    int next_index;
};

struct codebook {
    char* codes[256];
};

struct heap {
    struct tree** data;
    int length;
    int capacity;
};

bool is_leaf(const struct tree* t) {
    return !t-&gt;left &amp;&amp; !t-&gt;right;
}

void swap(struct tree** lhs, struct tree** rhs) {
    struct tree* tmp = *lhs;
    *lhs = *rhs;
    *rhs = tmp;
}

/* The two concat functions are horribly inefficient */
void concat(char** dst, const char* src) {
    int dst_len = strlen(*dst);
    int src_len = strlen(src);
    *dst = realloc(*dst, src_len + dst_len + 1);
    strcat(*dst, src);
}

void concat_char(char** dst, char c) {
    int len = strlen(*dst);
    *dst = realloc(*dst, len + 2);
    (*dst)[len] = c;
    (*dst)[len + 1] = &apos;\0&apos;;
}

char* duplicate(const char* src) {
    int length = strlen(src);
    char* dst = malloc(length + 1);
    memcpy(dst, src, length + 1);
    return dst;
}

void heap_push(struct heap* heap, struct tree* value) {
    if (heap-&gt;capacity == heap-&gt;length) {
        heap-&gt;capacity = heap-&gt;capacity == 0 ? 4 : heap-&gt;capacity * 2;
        heap-&gt;data = realloc(heap-&gt;data, heap-&gt;capacity * sizeof(struct tree*));
    }
    heap-&gt;data[heap-&gt;length++] = value;

    int index = heap-&gt;length - 1;
    while (index) {
        int parent_index = (index - 1) / 2;
        if (heap-&gt;data[parent_index]-&gt;count &lt;= heap-&gt;data[index]-&gt;count) {
            break;
        }

        swap(&amp;heap-&gt;data[parent_index], &amp;heap-&gt;data[index]);
        index = parent_index;
    }
}

struct tree* heap_pop(struct heap* heap) {
    if (!heap-&gt;length) {
        return NULL;
    }

    struct tree* result = heap-&gt;data[0];
    swap(&amp;heap-&gt;data[0], &amp;heap-&gt;data[--heap-&gt;length]);

    int index = 0;
    for (;;) {
        int target = index;
        int left = 2 * index + 1;
        int right = left + 1;

        if (left &lt; heap-&gt;length &amp;&amp;
                heap-&gt;data[left]-&gt;count &lt; heap-&gt;data[target]-&gt;count) {
            target = left;
        }

        if (right &lt; heap-&gt;length &amp;&amp;
                heap-&gt;data[right]-&gt;count &lt; heap-&gt;data[target]-&gt;count) {
            target = right;
        }

        if (target == index) {
            break;
        }

        swap(&amp;heap-&gt;data[index], &amp;heap-&gt;data[target]);
        index = target;
    }

    return result;
}

void heap_free(struct heap* heap) {
    free(heap-&gt;data);
}

struct tree* generate_tree(const char* str) {
    int counts[256] = { 0 };

    for (; *str != &apos;\0&apos;; ++str) {
        counts[(unsigned char)*str] += 1;
    }

    struct heap heap = { 0 };
    for (int i = 0; i &lt; sizeof(counts) / sizeof(int); ++i) {
        if (counts[i]) {
            struct tree* tree = calloc(1, sizeof(struct tree));
            tree-&gt;value = (char)i;
            tree-&gt;count = counts[i];
            heap_push(&amp;heap, tree);
        }
    }

    while (heap.length &gt; 1) {
        struct tree* left = heap_pop(&amp;heap);
        struct tree* right = heap_pop(&amp;heap);
        struct tree* branch = calloc(1, sizeof(struct tree));
        branch-&gt;count = left-&gt;count + right-&gt;count;
        branch-&gt;left = left;
        branch-&gt;right = right;
        heap_push(&amp;heap, branch);
    }

    struct tree* root = heap_pop(&amp;heap);
    heap_free(&amp;heap);
    return root;
}

void tree_free(struct tree* tree) {
    if (!tree) return;
    tree_free(tree-&gt;left);
    tree_free(tree-&gt;right);
    free(tree);
}

void codebook_recurse(const struct tree* tree,
                        struct bitstring_builder* builder,
                        struct codebook* codebook) {
    if (!tree) {
        return;
    }

    if (is_leaf(tree)) {
        builder-&gt;str[builder-&gt;next_index] = &apos;\0&apos;;
        codebook-&gt;codes[(unsigned char)tree-&gt;value] = duplicate(builder-&gt;str);
        return;
    }

    builder-&gt;str[builder-&gt;next_index++] = &apos;0&apos;;
    codebook_recurse(tree-&gt;left, builder, codebook);
    builder-&gt;next_index -= 1;

    builder-&gt;str[builder-&gt;next_index++] = &apos;1&apos;;
    codebook_recurse(tree-&gt;right, builder, codebook);
    builder-&gt;next_index -= 1;
}

struct codebook generate_codebook(const struct tree* tree) {
    struct codebook codebook = { .codes = { 0 } };
    struct bitstring_builder builder = { .str = { 0 }, .next_index = 0 };
    codebook_recurse(tree, &amp;builder, &amp;codebook);
    return codebook;
}

void codebook_free(struct codebook* codebook) {
    int size = sizeof(codebook-&gt;codes) / sizeof(codebook-&gt;codes[0]);
    for (int i = 0; i &lt; size; ++i) {
        free(codebook-&gt;codes[i]);
    }
}

const char* get_code(const struct codebook* codebook, char c) {
    return codebook-&gt;codes[(unsigned char)c];
}

char* encode(const char* input, struct tree** huffman_tree,
                struct codebook* codebook) {
    *huffman_tree = generate_tree(input);
    *codebook = generate_codebook(*huffman_tree);

    char* result = duplicate(get_code(codebook, *input));
    int result_length = strlen(result);
    int result_capacity = result_length;

    input += 1;

    for (; *input; ++input) {
        concat(&amp;result, get_code(codebook, *input));
    }

    return result;
}

const char* decode_recurse(const char* input, const struct tree* tree,
                            char** result) {
    if (!tree) {
        return input;
    }

    if (is_leaf(tree)) {
        concat_char(result, tree-&gt;value);
        return input;
    }

    if (*input == &apos;0&apos;) {
        return decode_recurse(input + 1, tree-&gt;left, result);
    } else {
        return decode_recurse(input + 1, tree-&gt;right, result);
    }
}

char* decode(const char* input, const struct tree* tree) {
    char* result = calloc(1, 1);
    do {
        input = decode_recurse(input, tree, &amp;result);
    } while (*input);
    return result;
}

int main() {
    struct tree* tree;
    struct codebook codebook;

    char* encoded = encode(&quot;bibbity bobbity&quot;, &amp;tree, &amp;codebook);
    char* decoded = decode(encoded, tree);

    printf(&quot;Codebook:\n&quot;);
    for (int i = 0; i &lt; 256; ++i) {
        if (codebook.codes[i]) {
            printf(&quot;%c %s\n&quot;, (char)i, codebook.codes[i]);
        }
    }

    printf(&quot;%s\n&quot;, encoded);
    printf(&quot;%s\n&quot;, decoded);

    tree_free(tree);
    codebook_free(&amp;codebook);
    free(encoded);
    free(decoded);
    return 0;
}
</code></pre>
</div><div class="code-method-sample" data-lang="hs" data-name="Haskell"><pre><code class="lang-haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> M
<span class="hljs-keyword">import</span>           Data.List (<span class="hljs-title">insert</span>, <span class="hljs-title">sort</span>)

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> <span class="hljs-type">Int</span> a</span>
            | <span class="hljs-type">Node</span> <span class="hljs-type">Int</span> (<span class="hljs-type">Tree</span> a) (<span class="hljs-type">Tree</span> a)
                   <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>, <span class="hljs-type">Eq</span>)

<span class="hljs-title">freq</span> :: <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">freq</span> (<span class="hljs-type">Leaf</span> i _)   = i
<span class="hljs-title">freq</span> (<span class="hljs-type">Node</span> i _ _) = i
<span class="hljs-class">
<span class="hljs-keyword">instance</span> (<span class="hljs-type">Eq</span> <span class="hljs-title">a</span>) =&gt; <span class="hljs-type">Ord</span> (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) <span class="hljs-keyword">where</span></span>
  compare t1 t2 = compare (freq t1) (freq t2)

<span class="hljs-title">getFrequencies</span> :: <span class="hljs-type">Ord</span> a =&gt; [a] -&gt; [(<span class="hljs-type">Int</span>, a)]
<span class="hljs-title">getFrequencies</span> = toSortedList . <span class="hljs-type">M</span>.fromListWith (+) . flip zip (repeat <span class="hljs-number">1</span>)
  <span class="hljs-keyword">where</span> toSortedList = sort . map swap . <span class="hljs-type">M</span>.toList
        swap (a, i) = (i, a)

<span class="hljs-title">buildTree</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; <span class="hljs-type">Maybe</span> (<span class="hljs-type">Tree</span> a)
<span class="hljs-title">buildTree</span> = build . map (uncurry <span class="hljs-type">Leaf</span>) . getFrequencies
  <span class="hljs-keyword">where</span> build []         = <span class="hljs-type">Nothing</span>
        build [t]        = <span class="hljs-type">Just</span> t
        build (t1:t2:ts) = build $ insert (<span class="hljs-type">Node</span> (freq t1 + freq t2) t1 t2) ts

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Bit</span> = <span class="hljs-type">Zero</span> | <span class="hljs-type">One</span></span>
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">Bit</span> <span class="hljs-keyword">where</span></span>
  show <span class="hljs-type">Zero</span> = <span class="hljs-string">&quot;0&quot;</span>
  show <span class="hljs-type">One</span> = <span class="hljs-string">&quot;1&quot;</span>

<span class="hljs-title">encode</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; (<span class="hljs-type">Maybe</span> (<span class="hljs-type">Tree</span> a), [<span class="hljs-type">Bit</span>])
<span class="hljs-title">encode</span> s = (tree, msg)
  <span class="hljs-keyword">where</span>
  tree = buildTree s
  msg = concatMap (table <span class="hljs-type">M</span>.!) s
  table = <span class="hljs-keyword">case</span> tree <span class="hljs-keyword">of</span>
    <span class="hljs-type">Nothing</span> -&gt; <span class="hljs-type">M</span>.empty
    <span class="hljs-type">Just</span> t  -&gt; <span class="hljs-type">M</span>.fromList $ mkTable (t, [])
  mkTable (<span class="hljs-type">Leaf</span> _ a, p)     = [(a, reverse p)]
  mkTable (<span class="hljs-type">Node</span> _ t1 t2, p) = concatMap mkTable [(t1,  <span class="hljs-type">Zero</span>:p), (t2, <span class="hljs-type">One</span>:p)]

<span class="hljs-title">decode</span> :: (<span class="hljs-type">Ord</span> a) =&gt; <span class="hljs-type">Maybe</span> (<span class="hljs-type">Tree</span> a) -&gt; [<span class="hljs-type">Bit</span>] -&gt; [a]
<span class="hljs-title">decode</span> <span class="hljs-type">Nothing</span> _ = []
<span class="hljs-title">decode</span> (<span class="hljs-type">Just</span> t) m = path t m
  <span class="hljs-keyword">where</span> path (<span class="hljs-type">Leaf</span> _ a) m            = a : path t m
        path (<span class="hljs-type">Node</span> _ t1 _) (<span class="hljs-type">Zero</span>: m) = path t1 m
        path (<span class="hljs-type">Node</span> _ _ t2) (<span class="hljs-type">One</span>: m)  = path t2 m
        path _ _                     = []

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;bibbity bobbity&quot;</span>
      (tree, encoded) = encode msg
      decoded = decode tree encoded
  putStrLn $ <span class="hljs-string">&quot;Endoding \&quot;&quot;</span> ++ msg ++ <span class="hljs-string">&quot;\&quot;: &quot;</span> ++ concatMap show encoded
  putStrLn $ <span class="hljs-string">&quot;Length: &quot;</span> ++ (show $ length encoded)
  putStrLn $ <span class="hljs-string">&quot;Decoding: &quot;</span> ++ decoded
</code></pre>
</div><div class="code-method-sample" data-lang="cs" data-name="C#"><h5 id="huffmancodingcs">HuffmanCoding.cs</h5>
<pre><code class="lang-csharp">// submitted by Julian Schacher (jspp), thanks to gustorn for the help
using System;
using System.Collections.Generic;
using System.Linq;

namespace HuffmanCoding
{
    public class EncodingResult
    {
        public string BitString { get; set; }
        public Dictionary&lt;char, string&gt; Dictionary { get; set; }
        public HuffmanCoding.Node Tree { get; set; }

        public EncodingResult(string bitString, Dictionary&lt;char, string&gt; dictionary, HuffmanCoding.Node tree)
        {
            this.BitString = bitString;
            this.Dictionary = dictionary;
            this.Tree = tree;
        }
    }

    public class HuffmanCoding
    {
        // The Node class used for the Huffman Tree.
        public class Node : IComparable&lt;Node&gt;
        {
            public Node LeftChild { get; set; }
            public Node RightChild { get; set; }
            public string BitString { get; set; } = &quot;&quot;;
            public int Weight { get; set; }
            public string Key { get; set; }

            public bool IsLeaf =&gt; LeftChild == null &amp;&amp; RightChild == null;

            // Creates a leaf. So just a node is created with the given values.
            public static Node CreateLeaf(char key, int weight) =&gt; new Node(key.ToString(), weight, null, null);
            // Creates a branch. Here a node is created by adding the keys and weights of both childs together.
            public static Node CreateBranch(Node leftChild, Node rightChild) =&gt; new Node(leftChild.Key + rightChild.Key, leftChild.Weight + rightChild.Weight, leftChild, rightChild);
            private Node(string key, int weight, Node leftChild, Node rightChild)
            {
                this.Key = key;
                this.Weight =  weight;
                this.LeftChild = leftChild;
                this.RightChild = rightChild;
            }

            public int CompareTo(Node other) =&gt; this.Weight - other.Weight;
        }

        // Node with biggest value at the top.
        class NodePriorityList
        {
            public int Count =&gt; nodes.Count;

            private List&lt;Node&gt; nodes = new List&lt;Node&gt;();

            public NodePriorityList() { }
            public NodePriorityList(List&lt;Node&gt; givenNodes)
            {
                this.nodes = givenNodes.ToList();
                this.nodes.Sort();
            }

            public void Add(Node newNode)
            {
                var index = this.nodes.BinarySearch(newNode);
                if (index &lt; 0)
                    this.nodes.Insert(~index, newNode);
                else
                    this.nodes.Insert(index, newNode);
            }

            public Node Pop()
            {
                var result = this.nodes[0];
                this.nodes.RemoveAt(0);
                return result;
            }
        }

        public EncodingResult Encode(string input)
        {
            var root = CreateTree(input);
            var dictionary = CreateDictionary(root);
            var bitString = CreateBitString(input, dictionary);

            return new EncodingResult(bitString, dictionary, root);
        }

        public string Decode(EncodingResult result)
        {
            var output = &quot;&quot;;
            Node currentNode = result.Tree;
            foreach (var bit in result.BitString)
            {
                // Go down the tree.
                if (bit == &apos;0&apos;)
                    currentNode = currentNode.LeftChild;
                else
                    currentNode = currentNode.RightChild;

                if (currentNode.IsLeaf)
                {
                    output += currentNode.Key;
                    currentNode = result.Tree;
                }
            }
            return output;
        }

        private Node CreateTree(string input)
        {
            // Create a List of all characters and their count in input by putting them into nodes.
            var nodes = input
                .GroupBy(c =&gt; c)
                .Select(n =&gt; Node.CreateLeaf(n.Key, n.Count()))
                .ToList();

            // Convert list of nodes to a NodePriorityList.
            var nodePriorityList = new NodePriorityList(nodes);

            // Create Tree.
            while (nodePriorityList.Count &gt; 1)
            {
                // Pop the two nodes with the smallest weights from the nodePriorityList and create a parentNode with the CreateBranch method. (This method adds the keys and weights of the childs together.)
                var leftChild = nodePriorityList.Pop();
                var rightChild = nodePriorityList.Pop();
                var parentNode = Node.CreateBranch(leftChild, rightChild);

                nodePriorityList.Add(parentNode);
            }

            return nodePriorityList.Pop();
        }

        private Dictionary&lt;char, string&gt; CreateDictionary(Node root)
        {
            // We&apos;re using a string instead of a actual bits here, since it makes the code somewhat more readable and this is an educational example.
            var dictionary = new Dictionary&lt;char, string&gt;();
            CreateDictionary(root, &quot;&quot;, dictionary);
            return dictionary;

            void CreateDictionary(Node node, string bitString, Dictionary&lt;char, string&gt; localDictionary)
            {
                if (node.IsLeaf)
                    localDictionary.Add(node.Key[0], bitString);
                else
                {
                    if (node.LeftChild != null)
                        CreateDictionary(node.LeftChild, bitString + &apos;0&apos;, localDictionary);
                    if (node.RightChild != null)
                        CreateDictionary(node.RightChild, bitString + &apos;1&apos;, localDictionary);
                }
            }
        }


        private string CreateBitString(string input, Dictionary&lt;char, string&gt; dictionary)
        {
            // We&apos;re using a string right here. While no compression is achieved with a string, it&apos;s the easiest way to display what the compressed result looks like. Also this is just an educational example.
            var bitString = &quot;&quot;;
            foreach (var character in input)
                bitString += dictionary[character];

            return bitString;
        }
    }
}
</code></pre>
<h5 id="programcs">Program.cs</h5>
<pre><code class="lang-csharp"><span class="hljs-comment">// submitted by Julian Schacher (jspp), thanks to gustorn for the help</span>
<span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">HuffmanCoding</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)
        </span>{
            <span class="hljs-keyword">var</span> huffmanCoding = <span class="hljs-keyword">new</span> HuffmanCoding();

            <span class="hljs-keyword">var</span> result = huffmanCoding.Encode(<span class="hljs-string">&quot;bibbity bobbity&quot;</span>);
            <span class="hljs-comment">// The bitStrings are just strings and provide no compression. Look in HuffmanCoding.cs for explanation.</span>
            <span class="hljs-comment">// Print dictionary.</span>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> entry <span class="hljs-keyword">in</span> result.Dictionary)
                System.Console.WriteLine($<span class="hljs-string">&quot;{entry.Key} {entry.Value}&quot;</span>);
            <span class="hljs-comment">// Print BitString.</span>
            System.Console.WriteLine($<span class="hljs-string">&quot;{result.BitString} count: {result.BitString.Length}&quot;</span>);

            <span class="hljs-keyword">var</span> originalString = huffmanCoding.Decode(result);
            System.Console.WriteLine(originalString);
        }
    }
}
</code></pre>
</div><div class="code-method-sample" data-lang="cpp" data-name="C++"><pre><code class="lang-cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstddef&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;

using std::begin;
using std::end;

namespace huffman {

[[noreturn]] inline void unreachable() {
  std::cerr &lt;&lt; &quot;this should never happen\n&quot;;
  std::abort();
}

// --- interface ---
class codebook {
  struct node {
    int frequency;

    node(int freq) : frequency(freq) {}
    virtual ~node() = 0;
  };

  // never null
  using node_ptr = std::unique_ptr&lt;node const&gt;;
  using bitstring = std::vector&lt;bool&gt;;

  // this is a flatmap between char and a bitstring
  // there should only ever be one character with a given
  // value at any time.
  using encoder_t = std::vector&lt;std::pair&lt;char, bitstring&gt;&gt;;

  struct leaf final : node {
    char key;

    leaf(int freq, char key) : node(freq), key(key) {}
  };

  struct branch final : node {
    node_ptr lhs;
    node_ptr rhs;

    branch(node_ptr lhs, node_ptr rhs)
        : node(lhs-&gt;frequency + rhs-&gt;frequency), lhs(std::move(lhs)),
          rhs(std::move(rhs)) {}
  };

  // this allows us to share [codebook]s among encoded strings
  struct data {
    node_ptr decoder;
    encoder_t encoder;
  };
  std::shared_ptr&lt;data const&gt; underlying_;

public:
  template &lt;typename Iter&gt;
  codebook(Iter const first, Iter const last);

  template &lt;typename Iter&gt;
  std::vector&lt;bool&gt; encode(Iter first, Iter last) const;

  template &lt;typename Iter&gt;
  std::string decode(Iter first, Iter last) const;
};

struct encoded_string {
  codebook codes;
  std::vector&lt;bool&gt; string;

  explicit encoded_string(std::string const&amp; s)
      : codes(begin(s), end(s)), string(codes.encode(begin(s), end(s))) {}

  encoded_string(codebook codes, std::string const&amp; s)
      : codes(codes), string(codes.encode(begin(s), end(s))) {}

  std::string decoded() const {
    return codes.decode(begin(string), end(string));
  }
};

// --- implementation ---
inline codebook::node::~node() {}

inline std::vector&lt;bool&gt; with_new_bit(std::vector&lt;bool&gt; bits, bool b) {
  bits.push_back(b);
  return bits;
}

template &lt;typename Iter&gt;
codebook::codebook(Iter const first, Iter const last) {
  struct helper {
    static node_ptr make_decoder(Iter const first, Iter const last) {
      // in this part of the function, we build up a frequency list
      // sorted by frequency, descending
      auto freq = std::vector&lt;leaf&gt;();

      std::for_each(first, last, [&amp;freq](char c) {
        auto const it = std::find_if(
            begin(freq), end(freq), [c](auto const&amp; p) { return p.key == c; });
        if (it != end(freq)) {
          // it&apos;s already in the list
          it-&gt;frequency += 1;
        } else {
          // it&apos;s not already in the list
          freq.emplace_back(1, c);
        }
      });

      if (freq.empty()) {
        throw std::invalid_argument(&quot;attempted to codebook an empty range&quot;);
      }

      std::sort(begin(freq), end(freq), [](auto const&amp; lhs, auto const&amp; rhs) {
        return lhs.frequency &gt; rhs.frequency;
      });

      auto ret = std::vector&lt;std::unique_ptr&lt;node&gt;&gt;();
      std::transform(
          begin(freq), end(freq), std::back_inserter(ret), [](auto const l) {
            return std::make_unique&lt;leaf&gt;(l);
          });

      while (ret.size() &gt; 1) {
        auto rhs = std::move(ret.back());
        ret.pop_back();
        auto lhs = std::move(ret.back());
        ret.pop_back();

        auto new_node =
            std::make_unique&lt;branch&gt;(std::move(lhs), std::move(rhs));
        auto const new_freq = new_node-&gt;frequency;

        // look for the first element with a smaller frequency
        auto const it =
            std::find_if(begin(ret), end(ret), [new_freq](auto const&amp; n) {
              return n-&gt;frequency &lt; new_freq;
            });
        // and insert the new_node before that element
        ret.insert(it, std::move(new_node));
        // in this way, we keep the list sorted by frequency
      }

      return std::move(ret.back());
    }

    static void
    encoder_rec(node const* cur, std::vector&lt;bool&gt; bits, encoder_t&amp; out) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(cur)) {
        out.push_back(std::make_pair(l-&gt;key, std::move(bits)));
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(cur)) {
        encoder_rec(b-&gt;lhs.get(), with_new_bit(bits, 0), out);
        encoder_rec(b-&gt;rhs.get(), with_new_bit(std::move(bits), 1), out);
      } else {
        unreachable();
      }
    }

    static encoder_t make_encoder(node const&amp; decoder) {
      auto ret = encoder_t();

      encoder_rec(&amp;decoder, std::vector&lt;bool&gt;(), ret);

      return ret;
    }
  };

  auto decoder = helper::make_decoder(first, last);
  auto encoder = helper::make_encoder(*decoder);
  underlying_ = std::make_shared&lt;data const&gt;(
      data{std::move(decoder), std::move(encoder)});
}

template &lt;typename Iter&gt;
std::vector&lt;bool&gt; codebook::encode(Iter const first, Iter const last) const {
  std::vector&lt;bool&gt; ret;

  auto&amp; encoder = underlying_-&gt;encoder;
  std::for_each(first, last, [&amp;ret, &amp;encoder](char c) {
    auto const it =
        std::find_if(begin(encoder), end(encoder), [c](auto const&amp; p) {
          return p.first == c;
        });
    if (it != end(encoder)) {
      auto const&amp; code = it-&gt;second;
      std::copy(begin(code), end(code), std::back_inserter(ret));
    } else {
      throw std::invalid_argument(
          &quot;The range has a character which was not in the huffman set&quot;);
    }
  });

  return ret;
}

template &lt;typename Iter&gt;
std::string codebook::decode(Iter const first, Iter const last) const {
  std::string ret;

  node const* const top = underlying_-&gt;decoder.get();

  // returns a pair:
  // the second member is the decoded character
  // the first member is the place we&apos;ve gotten to in the range
  // i.e., if [0] is an &apos;a&apos;, and we have
  // [it, last) = { 0, 1, 1, 0 }
  // we return (it&apos;, &apos;a&apos;) such that
  // [it&apos;, last) = { 1, 1, 0 }
  auto decode_single =
      [top](Iter it, Iter const last) -&gt; std::pair&lt;Iter, char&gt; {
    node const* current_node = top;

    for (; it != last; ++it) {
      if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
        return std::make_pair(it, l-&gt;key);
      } else if (auto b = dynamic_cast&lt;branch const*&gt;(current_node)) {
        if (*it) {
          current_node = b-&gt;rhs.get();
        } else {
          current_node = b-&gt;lhs.get();
        }
      } else {
        unreachable();
      }
    }

    if (auto l = dynamic_cast&lt;leaf const*&gt;(current_node)) {
      return std::make_pair(last, l-&gt;key);
    } else {
      throw std::invalid_argument(
          &quot;The range was not encoded with this huffman set&quot;);
    }
  };

  for (auto it = first; it != last;) {
    auto p = decode_single(it, last);
    it = p.first;
    ret.push_back(p.second);
  }

  return ret;
}

} // namespace huffman

int main() {
  std::string to_be_encoded = R&quot;(bibbity bobbity)&quot;;

  auto encoded = huffman::encoded_string(to_be_encoded);

  std::cout &lt;&lt; &quot;Encoded, the string looks like: &quot;;
  for (bool b : encoded.string) {
    std::cout &lt;&lt; b;
  }
  std::cout &lt;&lt; &quot;\nand decoded, the string looks like: &quot; &lt;&lt; encoded.decoded();
  std::cout &lt;&lt; &quot;\n\nAs opposed to the original, which is &quot;
            &lt;&lt; to_be_encoded.size() * 8 &lt;&lt; &quot; bits, the encoded has size &quot;
            &lt;&lt; encoded.string.size() &lt;&lt; &quot;.\n&quot;;
}
</code></pre>
</div><div class="code-method-sample" data-lang="clj" data-name="Clojure"><pre><code class="lang-clojure"><span class="hljs-comment">;; earthfail</span>
(<span class="hljs-name"><span class="hljs-builtin-name">ns</span></span> experiments.core)

<span class="hljs-comment">;; get a vector with chars and frequencies</span>

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> tree-string [st]
  <span class="hljs-string">&quot;take a string st and return the huffmantree with the frequency of
   each character included&quot;</span>
  <span class="hljs-comment">;; vector of [character frequency] pair</span>
  <span class="hljs-comment">;; for every char in string, added it to hash-map</span>
  <span class="hljs-comment">;; with value one if it doesn&apos;t exist or increment its value</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> cf-vec (<span class="hljs-name"><span class="hljs-builtin-name">vec</span></span>
               (<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [m c]
                         (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> m c (<span class="hljs-name"><span class="hljs-builtin-name">inc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> m c <span class="hljs-number">0</span>))))
                       {}
                       st)))
  <span class="hljs-comment">;; make a sorted list with nodes with bigger frequencies first</span>
  <span class="hljs-comment">;; take the last two which will help in dividing the tree</span>
  <span class="hljs-comment">;; the first and last elements before and after</span>
  <span class="hljs-comment">;; the smallest two in the tree shouldn&apos;t change</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">loop</span></span> [tree (<span class="hljs-name"><span class="hljs-builtin-name">sort-by</span></span> last &gt; cf-vec)]
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">count</span></span> tree) <span class="hljs-number">2</span>)
      (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> tree) <span class="hljs-comment">; only of tree is one node or nil</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [sorted-tree (<span class="hljs-name"><span class="hljs-builtin-name">sort-by</span></span> last &gt; tree)
            mid (<span class="hljs-name"><span class="hljs-builtin-name">take-last</span></span> <span class="hljs-number">2</span> sorted-tree)
            set-mid (<span class="hljs-name">set</span> mid)
            func (<span class="hljs-name"><span class="hljs-builtin-name">complement</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> contains? set-mid))
            firsty (<span class="hljs-name"><span class="hljs-builtin-name">take-while</span></span> func tree)
            [middle lasty] (<span class="hljs-name"><span class="hljs-builtin-name">split-at</span></span> <span class="hljs-number">2</span>
                                     (<span class="hljs-name"><span class="hljs-builtin-name">drop-while</span></span> func tree))]
        (<span class="hljs-name"><span class="hljs-builtin-name">recur</span></span>
         (<span class="hljs-name"><span class="hljs-builtin-name">concat</span></span>
          firsty
          <span class="hljs-comment">;; make a list with the two element in one list and</span>
          <span class="hljs-comment">;; the sum of their frequencies e.g</span>
          <span class="hljs-comment">;; &apos;(((node1 f1) (node2 f2)) f1+f2)</span>
          (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> middle (<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> #(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> %<span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">last</span></span> %<span class="hljs-number">2</span>)) <span class="hljs-number">0</span> middle)))
          lasty))))))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> remove-freq [tree]
  <span class="hljs-string">&quot;remove the frequencies in the huffmantree tree&quot;</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
    (<span class="hljs-name"><span class="hljs-builtin-name">char?</span></span> tree) tree                 <span class="hljs-comment">; check if this is a branch</span>
    <span class="hljs-comment">;; if the tree is a node and frequency then ignore frequency</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">integer?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">second</span></span> tree)) (<span class="hljs-name">remove-freq</span> (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> tree)) <span class="hljs-comment">;remove the frequency</span>
    <span class="hljs-comment">;; if the tree consists of two nodes then apply to both and combine</span>
    <span class="hljs-symbol">:else</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name">remove-freq</span> (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> tree))
                (<span class="hljs-name">remove-freq</span> (<span class="hljs-name"><span class="hljs-builtin-name">second</span></span> tree)))))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> hash-tree [tree]
  <span class="hljs-string">&quot;make a hashmap with code for each letter as key and the letter as
  value&quot;</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
    (<span class="hljs-name"><span class="hljs-builtin-name">char?</span></span> tree) {<span class="hljs-string">&quot;&quot;</span> tree}
    <span class="hljs-symbol">:else</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [left-map (<span class="hljs-name">hash-tree</span> (<span class="hljs-name"><span class="hljs-builtin-name">first</span></span> tree))
          right-map (<span class="hljs-name">hash-tree</span> (<span class="hljs-name"><span class="hljs-builtin-name">second</span></span> tree))
          func #(<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> hash-map         <span class="hljs-comment">; apply hash-map because</span>
                                        <span class="hljs-comment">; interleave return a seq</span>
                       (<span class="hljs-name">interleave</span>
                        (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">partial</span></span> str %<span class="hljs-number">2</span>) (<span class="hljs-name"><span class="hljs-builtin-name">keys</span></span> %<span class="hljs-number">1</span>)) <span class="hljs-comment">;add 0 or 1</span>
                                        <span class="hljs-comment">;to the start</span>
                                        <span class="hljs-comment">;of the keys</span>
                        (<span class="hljs-name"><span class="hljs-builtin-name">vals</span></span> %<span class="hljs-number">1</span>)))]
      <span class="hljs-comment">;; add &quot;0&quot; to the keys of left nodes and &quot;1&quot; to the right nodes</span>
      (<span class="hljs-name"><span class="hljs-builtin-name">merge</span></span> (<span class="hljs-name">func</span> left-map <span class="hljs-string">&quot;0&quot;</span>) (<span class="hljs-name">func</span> right-map <span class="hljs-string">&quot;1&quot;</span>)))))


(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> coder [s hash-coder]
  <span class="hljs-string">&quot;take a string s and return a coded string&quot;</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> str (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> hash-coder s)))

(<span class="hljs-name"><span class="hljs-builtin-name">defn</span></span> decoder [s hash-decoder]
  <span class="hljs-string">&quot;takes a string s and a hash-map hash-decoder and decode s&quot;</span>
  <span class="hljs-comment">;; code keyword in hashmap is for storing codes untill they are</span>
  <span class="hljs-comment">;; complete and can be decoded with the decoder</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">reduce</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">fn</span></span> [m code]             <span class="hljs-comment">; reduce return {:message</span>
                                        <span class="hljs-comment">; message,:code _}</span>
                 (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> [new-code (<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> (<span class="hljs-name">m</span> <span class="hljs-symbol">:code</span>) code)]
                   (<span class="hljs-name"><span class="hljs-builtin-name">if-let</span></span>  [letter (<span class="hljs-name"><span class="hljs-builtin-name">get</span></span> hash-decoder new-code)]
                     <span class="hljs-comment">;; if there is a letter then add it to :message</span>
                     <span class="hljs-comment">;; and revert :code to empty</span>
                     (<span class="hljs-name"><span class="hljs-builtin-name">assoc</span></span> (<span class="hljs-name">update</span> m <span class="hljs-symbol">:message</span> #(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> % letter))
                            <span class="hljs-symbol">:code</span> <span class="hljs-string">&quot;&quot;</span>)
                     <span class="hljs-comment">;; if there is not a letter then just add the</span>
                     <span class="hljs-comment">;; code letter to the :code</span>
                     (<span class="hljs-name">update</span> m <span class="hljs-symbol">:code</span> #(<span class="hljs-name"><span class="hljs-builtin-name">str</span></span> % code)))))
               {<span class="hljs-symbol">:message</span> <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-symbol">:code</span> <span class="hljs-string">&quot;&quot;</span>}
               s)
       <span class="hljs-symbol">:message</span>))           <span class="hljs-comment">;extract :message  value</span>
<span class="hljs-comment">;; ----------------EXAMPLE----------------</span>
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> st <span class="hljs-string">&quot;(bibbity bobbity)&quot;</span>)

(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> hash-decoder (<span class="hljs-name"><span class="hljs-builtin-name">-&gt;&gt;</span></span>
                   st
                   tree-string
                   remove-freq
                   hash-tree))
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> hash-coder (<span class="hljs-name">clojure.set/map-invert</span> hash-decoder))
(<span class="hljs-name">println</span> <span class="hljs-string">&quot;coding...&quot;</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">def</span></span> code (<span class="hljs-name">coder</span> st hash-coder))
(<span class="hljs-name">clojure.pprint/pprint</span> code)

(<span class="hljs-name">println</span> <span class="hljs-string">&quot;\ndecoding...&quot;</span>)
(<span class="hljs-name">clojure.pprint/pprint</span> (<span class="hljs-name">decoder</span> code hash-decoder))
</code></pre>
</div><div class="code-method-sample" data-lang="py" data-name="Python"><pre><code class="lang-python"><span class="hljs-comment"># Huffman Encoding</span>
<span class="hljs-comment"># Python 2.7+</span>
<span class="hljs-comment"># Submitted by Matthew Giallourakis</span>

<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

<span class="hljs-comment"># constructs the tree</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_huffman_tree</span><span class="hljs-params">(message)</span>:</span>

    <span class="hljs-comment"># get sorted list of character and frequency pairs</span>
    frequencies = Counter(message)
    trees = frequencies.most_common()

    <span class="hljs-comment"># while there is more than one tree</span>
    <span class="hljs-keyword">while</span> len(trees) &gt; <span class="hljs-number">1</span>:

        <span class="hljs-comment"># pop off the two trees of least weight from the trees list</span>
        tree_left,weight_left = trees.pop()
        tree_right,weight_right = trees.pop()

        <span class="hljs-comment"># combine the nodes and add back to the nodes list</span>
        new_tree = [tree_left, tree_right]
        new_weight = weight_left + weight_right

        <span class="hljs-comment"># find the first tree that has a weight smaller than new_weight and returns its index in the list</span>
        <span class="hljs-comment"># If no such tree can be found, use len(trees) instead to append</span>
        index = next((i <span class="hljs-keyword">for</span> i, tree <span class="hljs-keyword">in</span> enumerate(trees) <span class="hljs-keyword">if</span> tree[<span class="hljs-number">1</span>] &lt; new_weight), len(trees))

        <span class="hljs-comment"># insert the new tree there</span>
        trees.insert(index, (new_tree, new_weight))

    huffman_tree = trees[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> huffman_tree

<span class="hljs-comment"># constructs the mapping with recursion</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_codebook</span><span class="hljs-params">(tree, code=<span class="hljs-string">&apos;&apos;</span>)</span>:</span>

    codebook = []

    <span class="hljs-comment"># split the tree</span>
    left_tree, right_tree = tree

    <span class="hljs-comment"># if the left node has children, find the mapping of those children</span>
    <span class="hljs-comment"># else pair the character with the current code + 0</span>
    <span class="hljs-keyword">if</span> type(left_tree) <span class="hljs-keyword">is</span> list:
        codebook += build_codebook(left_tree, code+<span class="hljs-string">&apos;0&apos;</span>)
    <span class="hljs-keyword">else</span>:
        codebook.append((left_tree, code+<span class="hljs-string">&apos;0&apos;</span>))

    <span class="hljs-comment"># if the right node has children, find the mapping of those children</span>
    <span class="hljs-comment"># else pair the character with the current code + 1</span>
    <span class="hljs-keyword">if</span> type(right_tree) <span class="hljs-keyword">is</span> list:
        codebook += build_codebook(right_tree, code+<span class="hljs-string">&apos;1&apos;</span>)
    <span class="hljs-keyword">else</span>:
        codebook.append((right_tree, code+<span class="hljs-string">&apos;1&apos;</span>))
    <span class="hljs-keyword">return</span> codebook

<span class="hljs-comment"># encodes the message</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">huffman_encode</span><span class="hljs-params">(codebook, message)</span>:</span>

    encoded_message = <span class="hljs-string">&apos;&apos;</span>

    <span class="hljs-comment"># build a char -&gt; code dictionary</span>
    forward_dict = dict(codebook)

    <span class="hljs-comment"># replace each character with its code</span>
    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> message:
        encoded_message += forward_dict[char]

    <span class="hljs-keyword">return</span> encoded_message

<span class="hljs-comment"># decodes a message</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">huffman_decode</span><span class="hljs-params">(codebook, encoded_message)</span>:</span>

    decoded_message = <span class="hljs-string">&apos;&apos;</span>
    key = <span class="hljs-string">&apos;&apos;</span>

    <span class="hljs-comment"># build a code -&gt; char dictionary</span>
    inverse_dict = dict([(v, k) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> codebook])

    <span class="hljs-comment"># for each bit in the encoding</span>
    <span class="hljs-comment"># if the bit is in the dictionary, replace the bit with the paired character</span>
    <span class="hljs-comment"># else look at the bit and the following bits together until a match occurs</span>
    <span class="hljs-comment"># move to the next bit not yet looked at</span>
    <span class="hljs-keyword">for</span> index, bit <span class="hljs-keyword">in</span> enumerate(encoded_message):
        key += bit
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> inverse_dict:
            decoded_message += inverse_dict[key]
            key = <span class="hljs-string">&apos;&apos;</span>

    <span class="hljs-keyword">return</span> decoded_message

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>

    <span class="hljs-comment"># test example</span>
    message = <span class="hljs-string">&apos;bibbity_bobbity&apos;</span>
    tree = build_huffman_tree(message)
    codebook = build_codebook(tree)
    encoded_message = huffman_encode(codebook, message)
    decoded_message = huffman_decode(codebook, encoded_message)

    print(<span class="hljs-string">&apos;message: &apos;</span> + message)
    print(<span class="hljs-string">&apos;huffman tree: &apos;</span> + str(tree))
    print(<span class="hljs-string">&apos;codebook: &apos;</span> + str(codebook))
    print(<span class="hljs-string">&apos;encoded message: &apos;</span> + encoded_message)
    print(<span class="hljs-string">&apos;decoded message: &apos;</span> + decoded_message)

    <span class="hljs-comment"># prints the following:</span>
    <span class="hljs-comment">#</span>
    <span class="hljs-comment">#  message: bibbity_bobbity</span>
    <span class="hljs-comment">#  huffman_tree: [&apos;b&apos;, [[[&apos;_&apos;, &apos;o&apos;], &apos;y&apos;], [&apos;t&apos;, &apos;i&apos;]]]</span>
    <span class="hljs-comment">#  codebook: [(&apos;b&apos;, &apos;0&apos;), (&apos;_&apos;, &apos;1000&apos;), (&apos;o&apos;, &apos;1001&apos;),</span>
    <span class="hljs-comment">#             (&apos;y&apos;, &apos;101&apos;), (&apos;t&apos;, &apos;110&apos;), (&apos;i&apos;, &apos;111&apos;)]</span>
    <span class="hljs-comment">#  encoded_message: 01110011111010110000100100111110101</span>
    <span class="hljs-comment">#  decoded_message: bibbity_bobbity</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&apos;__main__&apos;</span>:
    main()
</code></pre>
</div><div class="code-method-sample" data-lang="js" data-name="JavaScript"><pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">const</span> tree = createTree(str);
  <span class="hljs-keyword">const</span> codebook = createCodebook(tree);
  <span class="hljs-keyword">return</span> {
    string: [...str].map(c =&gt; codebook[c]).join(<span class="hljs-string">&quot;&quot;</span>),
    tree,
    codebook
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTree</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">const</span> chars = [...str];
    <span class="hljs-keyword">const</span> charCounts = chars.reduce((counts, char) =&gt; {
      counts[char] = (counts[char] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> counts;
    }, {});

    <span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Object</span>.entries(charCounts).map(([key, weight]) =&gt; ({ key, weight }));
    <span class="hljs-keyword">const</span> priorityQueue = makeQueue(nodes);
    <span class="hljs-keyword">while</span> (priorityQueue.data.length &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> left = priorityQueue.dequeue();
      <span class="hljs-keyword">const</span> right = priorityQueue.dequeue();
      priorityQueue.enqueue({ weight: left.weight + right.weight, left, right });
    }
    <span class="hljs-keyword">return</span> priorityQueue.dequeue();
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCodebook</span>(<span class="hljs-params">tree</span>) </span>{
    <span class="hljs-keyword">return</span> recurse(tree, <span class="hljs-string">&quot;&quot;</span>, {});

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recurse</span>(<span class="hljs-params">node, bitstring, dict</span>) </span>{
      <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) {
        dict[node.key] = bitstring;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (node.left) {
          recurse(node.left, bitstring + <span class="hljs-string">&quot;0&quot;</span>, dict);
        }

        <span class="hljs-keyword">if</span> (node.right) {
          recurse(node.right, bitstring + <span class="hljs-string">&quot;1&quot;</span>, dict);
        }
      }
      <span class="hljs-keyword">return</span> dict;
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decode</span>(<span class="hljs-params">bitstring, tree</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> node = tree;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> bit <span class="hljs-keyword">of</span> [...bitstring]) {
    node = bit === <span class="hljs-string">&quot;0&quot;</span> ? node.left : node.right;
    <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) {
      result.push(node.key);
      node = tree;
    }
  }

  <span class="hljs-keyword">return</span> result.join(<span class="hljs-string">&quot;&quot;</span>);
}

<span class="hljs-comment">// This queue implementation is horribly inefficient, but a proper, heap-based implementation would</span>
<span class="hljs-comment">// be longer that the algorithm itself</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeQueue</span>(<span class="hljs-params">iterable</span>) </span>{
  <span class="hljs-keyword">return</span> {
    data: [...iterable].sort((a, b) =&gt; a.weight - b.weight),
    enqueue(value) {
      <span class="hljs-keyword">const</span> target = <span class="hljs-keyword">this</span>.data.findIndex(x =&gt; x.weight &gt; value.weight);
      <span class="hljs-keyword">if</span> (target === <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">this</span>.data.push(value);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.data = [...this.data.slice(<span class="hljs-number">0</span>, target), value, ...this.data.slice(target)];
      }
    },
    dequeue() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data.shift();
    }
  };
}

<span class="hljs-keyword">const</span> encoded = encode(<span class="hljs-string">&quot;bibbity bobbity&quot;</span>);
<span class="hljs-keyword">const</span> decoded = decode(encoded.string, encoded.tree);
<span class="hljs-built_in">console</span>.log(encoded.string);
<span class="hljs-built_in">console</span>.log(decoded);
</code></pre>
</div><div class="code-method-sample" data-lang="java" data-name="Java"><pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
    String letter = <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-keyword">int</span> frequency = <span class="hljs-number">0</span>;
    TreeNode left = <span class="hljs-keyword">null</span>, right = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(String letter, <span class="hljs-keyword">int</span> frequency)</span> </span>{
        <span class="hljs-keyword">this</span>.letter = letter;
        <span class="hljs-keyword">this</span>.frequency = frequency;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> frequency, TreeNode left, TreeNode right)</span> </span>{
        <span class="hljs-keyword">this</span>.frequency = frequency;
        <span class="hljs-keyword">this</span>.left = left;
        <span class="hljs-keyword">this</span>.right = right;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTree</span> </span>{
    <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; frequencyMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; codeBook = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(), reverseCodeBook = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">private</span> TreeNode root;
    <span class="hljs-keyword">private</span> String stringToEncode;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HuffmanTree</span><span class="hljs-params">(String stringToEncode)</span> </span>{
        <span class="hljs-keyword">this</span>.stringToEncode = stringToEncode;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTree</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stringToEncode.length(); i++) {
            String key = Character.toString(stringToEncode.charAt(i));
            <span class="hljs-keyword">if</span> (!frequencyMap.containsKey(key)) {
                frequencyMap.put(key, <span class="hljs-number">1</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> frequency = frequencyMap.get(key) + <span class="hljs-number">1</span>;
                frequencyMap.replace(key, frequency);
            }
        }
        Queue&lt;TreeNode&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o.frequency));
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; m : frequencyMap.entrySet()) {
            priorityQueue.add(<span class="hljs-keyword">new</span> TreeNode(m.getKey(), m.getValue()));
        }
        <span class="hljs-keyword">while</span> (priorityQueue.size() &gt; <span class="hljs-number">1</span>) {
            TreeNode left = priorityQueue.remove();
            TreeNode right = priorityQueue.remove();
            priorityQueue.add(<span class="hljs-keyword">new</span> TreeNode(left.frequency + right.frequency, left, right));
        }
        root = priorityQueue.remove();
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode node, StringBuilder code)</span> </span>{
        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) {
            codeBook.put(node.letter, code.toString());
        }
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) {
            traverse(node.left, code.append(<span class="hljs-number">0</span>));
            code.deleteCharAt(code.length() - <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) {
            traverse(node.right, code.append(<span class="hljs-number">1</span>));
            code.deleteCharAt(code.length() - <span class="hljs-number">1</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printCodeBook</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">&quot;Code Book&quot;</span>);
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; m : codeBook.entrySet()) {
            System.out.println(m.getKey() + <span class="hljs-string">&quot;\t&quot;</span> + m.getValue());
        }
        System.out.println();
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CodeBookReverse</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; m : codeBook.entrySet()) {
            reverseCodeBook.put(m.getValue(), m.getKey());
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">()</span> </span>{
        traverse(root, <span class="hljs-keyword">new</span> StringBuilder());
        StringBuilder encode = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stringToEncode.length(); i++) {
            String k = Character.toString(stringToEncode.charAt(i));
            encode.append(codeBook.get(k));
        }
        printCodeBook();
        <span class="hljs-keyword">return</span> encode.toString();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decode</span><span class="hljs-params">(String encoded)</span> </span>{
        StringBuilder decoded = <span class="hljs-keyword">new</span> StringBuilder(), key = <span class="hljs-keyword">new</span> StringBuilder();
        CodeBookReverse();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; encoded.length(); i++) {
            key = key.append(encoded.charAt(i));
            <span class="hljs-keyword">if</span> (reverseCodeBook.containsKey(key.toString())) {
                decoded.append(reverseCodeBook.get(key.toString()));
                key = <span class="hljs-keyword">new</span> StringBuilder();
            }
        }
        <span class="hljs-keyword">return</span> decoded.toString();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        HuffmanTree huffmanTree = <span class="hljs-keyword">new</span> HuffmanTree(<span class="hljs-string">&quot;bibbity_bobbity&quot;</span>);
        huffmanTree.createTree();
        String encoded = huffmanTree.encode();
        System.out.println(<span class="hljs-string">&quot;Encoded String: &quot;</span> + encoded);
        System.out.println(<span class="hljs-string">&quot;Decoded String: &quot;</span> + huffmanTree.decode(encoded));
    }
}
</code></pre>
</div><div class="code-method-sample" data-lang="go" data-name="Go"><pre><code class="lang-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;container/heap&quot;</span>
    <span class="hljs-string">&quot;fmt&quot;</span>
)

<span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> {
    freq  <span class="hljs-keyword">int</span>
    char  <span class="hljs-keyword">rune</span>
    left  *node
    right *node
}

<span class="hljs-keyword">type</span> codebook <span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>]<span class="hljs-keyword">string</span>
<span class="hljs-keyword">type</span> nodeHeap []*node

<span class="hljs-keyword">func</span> (n nodeHeap) Len() <span class="hljs-keyword">int</span>           { <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(n) }
<span class="hljs-keyword">func</span> (n nodeHeap) Less(i, j <span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span> { <span class="hljs-keyword">return</span> n[i].freq &gt; n[j].freq }
<span class="hljs-keyword">func</span> (n nodeHeap) Swap(i, j <span class="hljs-keyword">int</span>)      { n[i], n[j] = n[j], n[i] }

<span class="hljs-keyword">func</span> (n *nodeHeap) Push(x <span class="hljs-keyword">interface</span>{}) {
    <span class="hljs-keyword">if</span> node, ok := x.(*node); ok {
        *n = <span class="hljs-built_in">append</span>(*n, node)
    } <span class="hljs-keyword">else</span> {
        fmt.Printf(<span class="hljs-string">&quot;I got a node of Type %T\n&quot;</span>, x)
    }
}

<span class="hljs-keyword">func</span> (n *nodeHeap) Pop() <span class="hljs-keyword">interface</span>{} {
    old := *n
    l := <span class="hljs-built_in">len</span>(old)
    x := old[l<span class="hljs-number">-1</span>]
    *n = old[<span class="hljs-number">0</span> : l<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">return</span> x
}

<span class="hljs-keyword">func</span> buildTree(message <span class="hljs-keyword">string</span>) *node {
    freqMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>]*node)
    h := <span class="hljs-built_in">new</span>(nodeHeap)
    heap.Init(h) <span class="hljs-comment">// really needed?</span>

    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> message {
        <span class="hljs-keyword">if</span> _, ok := freqMap[char]; ok {
            freqMap[char].freq++
        } <span class="hljs-keyword">else</span> {
            newNode := <span class="hljs-built_in">new</span>(node)
            newNode.freq = <span class="hljs-number">1</span>
            newNode.char = char
            freqMap[char] = newNode
            heap.Push(h, newNode)
        }
    }

    <span class="hljs-keyword">for</span> h.Len() &gt; <span class="hljs-number">1</span> {
        left, right := h.Pop().(*node), h.Pop().(*node)
        branch := <span class="hljs-built_in">new</span>(node)
        branch.freq = right.freq + left.freq
        branch.left = left
        branch.right = right
        heap.Push(h, branch)
    }

    root := heap.Pop(h).(*node)
    <span class="hljs-keyword">return</span> root
}

<span class="hljs-keyword">func</span> codebookRecurse(node *node, cb *codebook, code []<span class="hljs-keyword">rune</span>) {
    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">if</span> node.left == <span class="hljs-literal">nil</span> &amp;&amp; node.right == <span class="hljs-literal">nil</span> {
        (*cb)[node.char] = <span class="hljs-keyword">string</span>(code)
    }

    code = <span class="hljs-built_in">append</span>(code, <span class="hljs-string">&apos;0&apos;</span>)
    codebookRecurse(node.left, cb, code)
    code = <span class="hljs-built_in">append</span>(code[:<span class="hljs-built_in">len</span>(code)<span class="hljs-number">-1</span>], <span class="hljs-string">&apos;1&apos;</span>)
    codebookRecurse(node.right, cb, code)
}

<span class="hljs-keyword">func</span> encode(message <span class="hljs-keyword">string</span>) (<span class="hljs-keyword">string</span>, *node, codebook) {
    ret := <span class="hljs-string">&quot;&quot;</span>
    root := buildTree(message)
    cb := generateCodebook(root)
    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> message {
        ret += cb[char]
    }

    <span class="hljs-keyword">return</span> ret, root, cb
}

<span class="hljs-keyword">func</span> decode(message <span class="hljs-keyword">string</span>, root *node) <span class="hljs-keyword">string</span> {
    cur := root
    ret := <span class="hljs-string">&quot;&quot;</span>

    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> message {
        <span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> message
        }

        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(char) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0&quot;</span>:
            <span class="hljs-keyword">if</span> cur.left == <span class="hljs-literal">nil</span> {
                ret += <span class="hljs-keyword">string</span>(cur.char)
                cur = root.left
            } <span class="hljs-keyword">else</span> {
                cur = cur.left
            }
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:
            <span class="hljs-keyword">if</span> cur.right == <span class="hljs-literal">nil</span> {
                ret += <span class="hljs-keyword">string</span>(cur.char)
                cur = root.right
            } <span class="hljs-keyword">else</span> {
                cur = cur.right
            }
        }
    }

    <span class="hljs-keyword">if</span> cur.char != <span class="hljs-number">0</span> {
        ret += <span class="hljs-keyword">string</span>(cur.char)
    }

    <span class="hljs-keyword">return</span> ret
}

<span class="hljs-keyword">func</span> generateCodebook(root *node) codebook {
    cb := <span class="hljs-built_in">make</span>(codebook)
    codeArr := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">rune</span>, <span class="hljs-number">0</span>)
    codebookRecurse(root, &amp;cb, codeArr)
    <span class="hljs-keyword">return</span> cb
}

<span class="hljs-keyword">func</span> main() {
    enc, root, cb := encode(<span class="hljs-string">&quot;bibbity_bobbity&quot;</span>)
    fmt.Println(<span class="hljs-string">&quot;Codebook:&quot;</span>)
    <span class="hljs-keyword">for</span> r, c := <span class="hljs-keyword">range</span> cb {
        fmt.Println(<span class="hljs-keyword">string</span>(r), <span class="hljs-string">&quot;-&gt;&quot;</span>, c)
    }
    fmt.Println(<span class="hljs-string">&quot;\nEncoded:&quot;</span>, enc)
    fmt.Println(<span class="hljs-string">&quot;Decoded:&quot;</span>, decode(enc, root))
}
</code></pre>
</div><div class="code-method-sample" data-lang="asm-x64" data-name="X86-64 Assembly"><pre><code class="lang-asm-x64">.intel_syntax noprefix

# System V calling convention cheatsheet
# Params: rdi, rsi, rdx, rcx, r8, r9, xmm0-7
# Return: rax (int 64 bits), rax:rdx (int 128 bits), xmm0 (float)
# Callee cleanup: rbx, rbp, r12-15
# Scratch: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11

.section .rodata
  text:       .string &quot;bibbity bobbity&quot;
  original:   .string &quot;Original message: %s\n&quot;
  encoded:    .string &quot;Encoded message: &quot;
  decoded:    .string &quot;Decoded message: %s\n&quot;

  .equ bitstr_len,       32
  .equ bitstr_size,      40
  .equ codebook_size,    256 * bitstr_size

  .equ tree_left,        0
  .equ tree_right,       8
  .equ tree_count,       16
  .equ tree_value,       20
  .equ tree_size,        24

  .equ heap_len,         0
  .equ heap_data,        4
  .equ heap_size,        512 * 8 + 16         # 512 ptrs + 4 byte length + 12 byte padding
  .equ counts_size,      256 * 4

  .equ msg_len,          0
  .equ msg_data,         8
.section .text
  .global main
  .extern printf, calloc, malloc, memset, puts

main:
  push   r12
  push   r13
  sub    rsp, codebook_size + 16              # 8 extra bytes for the Huffman-tree ptr, 8 bytes for padding

  # Print the original text
  mov    rdi, OFFSET original
  mov    rsi, OFFSET text
  xor    rax, rax
  call   printf

  # First encode the text. This will also initialize the Huffman-tree and the codebook
  mov    rdi, OFFSET text
  mov    rsi, rsp
  lea    rdx, [rsp + codebook_size]
  call   encode
  mov    r12, rax                             # Save the returned message ptr

  # Print the codebook and the encoded message
  mov    rdi, rsp
  call   print_codebook
  mov    rdi, OFFSET encoded
  xor    rax, rax
  call   printf
  mov    rdi, r12
  call   print_message

  # Decode and print the message
  mov    rdi, r12
  mov    rsi, QWORD PTR [rsp + codebook_size]
  call   decode
  mov    r13, rax
  mov    rdi, OFFSET decoded
  mov    rsi, r13
  xor    rax, rax
  call   printf

  # Free allocated resources
  mov    rdi, r12
  call   free
  mov    rdi, r13
  call   free
  mov    rdi, QWORD PTR [rsp + codebook_size]
  call   free_tree

  add    rsp, codebook_size + 16
  pop    r13
  pop    r12

  # Indiciate success with a 0 exit code
  xor    rax, rax
  ret

# rdi - text
# rsi - codebook ptr
# rdx - Huffman-tree ptr
# RET rax - encoded message ptr
encode:
  push   r12
  push   r13
  push   r14
  mov    r12, rdi                             # Save the original arguments
  mov    r13, rsi
  mov    r14, rdx
  call   generate_tree                        # The text is already in rdi
  mov    QWORD PTR [r14], rax                 # Save the Huffman-tree&apos;s root
  mov    rdi, r13                             # Set up the parameters for codebook generation: codebook ptr, Huffman-tree root
  mov    rsi, rax
  call   generate_codebook
  xor    rax, rax
  xor    r14, r14                             # We&apos;ll use r14 to keep track of the length of the message
  mov    rcx, r12                             # Make a copy of the pointer to the message to be encoded
encode_calculate_length:
  mov    al, BYTE PTR [rcx]
  test   al, al                               # If we&apos;re at the terminating null character then we&apos;re ready to encode
  jz     encode_message
  lea    rdx, [rax + 4*rax]                   # We get the codebook entry at the specific index
  lea    r8, [r13 + 8*rdx]
  add    r14, QWORD PTR [r8 + bitstr_len]     # And add the encoded word length to the total
  inc    rcx
  jmp    encode_calculate_length
encode_message:
  mov    rdi, 1
  lea    rsi, [r14 + 7]                       # Calculate the number of bytes we need to allocate to fit all the bits
  shr    rsi, 3                               # length % 8 rounded up = (length + 8 - 1) / 8
  lea    rsi, [rsi + 8]                       # Make space for an 8-byte length field
  call   calloc                               # Allocate the necessary memory, the message will be in rax
  mov    QWORD PTR [rax], r14                 # Save the length of the message
  # Registers:
  #   - r12: text
  #   - r13: codebook_ptr
  #   - rax: message ptr
  #   - free to use: rdi, rsi, rcx, rdx, r8, r9, r10, r11, r14
  xor    r8, r8                               # Bit offset
  lea    r9, [rax + 8]                        # 8-byte message block
encode_message_bits:
  xor    rdi, rdi                             # We need to clear rdi because moving a single byte to dil doesn&apos;t do so
  mov    dil, BYTE PTR [r12]                  # Iterate the message again
  test   dil, dil                             # If we&apos;re at the the null terminator we&apos;re done
  jz     encode_done
  lea    rdx, [rdi + 4*rdi]                   # Get the codebook entry
  lea    r10, [r13 + 8*rdx]
  mov    r11, QWORD PTR [r10 + bitstr_len]    # Load the bitstring length
  lea    r14, [r10]                           # The bitstring qword we&apos;re currently processing
encode_message_bits_qword:
  mov    rdi, QWORD PTR [r14]                 # Calculate the first mask: [code qword] &lt;&lt; [bit offset]
  mov    rsi, rdi                             # Get a second copy of the code&apos;s current qword
  mov    rcx, r8
  shl    rdi, cl
  or     QWORD PTR [r9], rdi                  # Apply the mask to the current block
  mov    rcx, 64                              # Calculate the second mask: [code qword] &gt;&gt; [64 - bit offset]
  sub    rcx, r8
  shr    rsi, cl
  mov    rcx, r11                             # Copy the code length so we can manipulate it without destroying the original value
  sub    rcx, 64
  jle    encode_message_bits_try_overflow     # If the length was less than or equal to 64, check if the code qword would overflow the current message block
  mov    r11, rcx                             # We wanted to subtract 64 from the code length anyway
  lea    r9, [r9 + 8]                         # Load the next message block
  or     QWORD PTR [r9], rsi                  # Save the second mask to the new message block
  jmp    encode_message_bits_qword
encode_message_bits_try_overflow:
  add    rcx, r8                              # Calculate [code length] + [bit offset] - 64
  jl     encode_calculate_new_bit_offset      # If the result is less than 0 then we have no remaining bits -&gt; calculate the new bit offset
  mov    r8, rcx                              # Otherwise this also happens to be our new bit offset
  lea    r9, [r9 + 8]                         # Load the next message block
  or     QWORD PTR [r9], rsi                  # Save the second mask to the new message block
  inc    r12                                  # Go to the next character in the input
  jmp    encode_message_bits
encode_calculate_new_bit_offset:
  lea    r8, [r8 + r11]                       # Calculate the bit offset for the next code qword
  inc    r12
  jmp    encode_message_bits
encode_done:
  pop    r14
  pop    r13
  pop    r12
  ret

# rdi - encoded message
# rsi - Huffman-tree root (ptr)
# RET rax - the decoded message
decode:
  push   r12
  push   r13
  push   r14
  mov    r12, rdi
  mov    r13, rsi
  mov    rdi, QWORD PTR [r12]                 # Load the length of the message
  mov    r14, rdi                             # We&apos;ll use the length of the message as a loop counter later
  lea    rdi, [rdi + 1]                       # The null terminator
  call   malloc                               # This will usually be more than enough memory to contain the whole decoded message (we don&apos;t handle pathological cases right now)
  mov    rdi, r12                             # The single-character decoder doesn&apos;t touch rdi so we can hoist it before the loop
  xor    rcx, rcx
  mov    rdx, rax                             # The current byte in the output string
decode_loop:
  cmp    rcx, r14                             # The encoded message bit counter
  jge    decode_done
  mov    rsi, r13                             # The current node in the Huffman-tree
decode_loop_char:
  test   rsi, rsi                             # If the Huffman-tree node is null then we reached a dead-end -&gt; start over
  jz     decode_loop
  cmp    QWORD PTR [rsi + tree_left], 0       # If the node has either a left or a right child, treat it as a branch
  jnz    decode_loop_char_branch
  cmp    QWORD PTR [rsi + tree_right], 0
  jnz    decode_loop_char_branch
  mov    r9d, DWORD PTR [rsi + tree_value]    # Load the value in this node in case the next iteration needs it
  mov    BYTE PTR [rdx], r9b                  # And save it to the output
  lea    rdx, [rdx + 1]                       # Advance the output string
  jmp    decode_loop
decode_loop_char_branch:
  mov    r9, rcx                              # First, load the byte of the message the current bit is in
  shr    r9, 3
  mov    r10b, BYTE PTR [rdi + r9 + msg_data]
  mov    r11, rcx                             # Save rcx in another register temporarily so we can restore it without push/pop
  and    rcx, 7
  shr    r10, cl                              # Get the bit we&apos;re interested in to position 0
  lea    rcx, [r11 + 1]                       # Restore rcx and immediately add 1 to get the next bit to decode
  and    r10, 0x1                             # Zero out all other bits
  mov    r8, rsi
  mov    rsi, QWORD PTR [r8 + tree_left]      # Take the left branch for 0, the right branch for a non-zero bit
  cmovnz rsi, QWORD PTR [r8 + tree_right]
  jmp    decode_loop_char
decode_done:
  mov    BYTE PTR [rdx], 0                    # Write the null terminator at the end of the string
  pop    r14
  pop    r13
  pop    r12
  ret

# rdi - The starting address of the codebook we want to generate
# rsi - Huffman-tree root (ptr)
generate_codebook:
  push   r12
  sub    rsp, bitstr_size + 16                # 16 extra bytes for alignment
  mov    r12, rsi
  xorps  xmm0, xmm0                           # Create a 0-initialized bitstring. This will be
  movaps XMMWORD PTR [rsp], xmm0              # used in the recursive function calls
  movaps XMMWORD PTR [rsp + 16], xmm0
  mov    QWORD PTR [rsp + 32], 0
  xor    rsi, rsi
  mov    rdx, codebook_size
  call   memset
  mov    rdi, rax
  mov    rsi, r12
  mov    rdx, rsp
  call   generate_codebook_recurse
  add    rsp, bitstr_size + 16
  pop    r12
  ret

# rdi - The codebook&apos;s starting address
# rsi - The current Huffman-tree node
# rdx - The bitstring used for code generation
generate_codebook_recurse:
  push   rbp
  push   r12
  push   r13
  test   rdi, rdi                             # If we reached a null pointer we&apos;re done
  jz     generate_codebook_recurse_done
  mov    r12, rsi
  cmp    QWORD PTR [r12 + tree_left], 0       # If at least one of the children is not null
  jnz    generate_codebook_branch             # then we need to treat the current node as a branch
  cmp    QWORD PTR [r12 + tree_right], 0
  jnz    generate_codebook_branch
  mov    r8d, DWORD PTR [r12 + tree_value]    # Get the value of the current node
  movaps xmm0, XMMWORD PTR [rdx]              # Get the values of the current bitstring into some registers
  movaps xmm1, XMMWORD PTR [rdx + 16]
  mov    r9, QWORD PTR [rdx + 32]
  lea    rax, [r8 + 4*r8]                     # The index calculation needs to add 40 * index. With lea arithmetic this can be represented as
  lea    r10, [rdi + 8*rax]                   # base address + 8 * (5 * index). This is done in two lea instructions
  movups XMMWORD PTR [r10], xmm0              # And copy the data over to it
  movups XMMWORD PTR [r10 + 16], xmm1
  mov    QWORD PTR [r10 + 32], r9
  jmp    generate_codebook_recurse_done
generate_codebook_branch:
  # First, calculate the necessary indices and bitmask to use for the bitstring
  mov    r13, QWORD PTR [rdx + bitstr_len]    # Load the current length of the bitstring
  mov    rcx, r13                             # This will be used to index into the bitstring data. We&apos;ll need two copies for it
  shr    r13, 6                               # We first get which 64 bit chunk of the bitstring we want to modify
  and    rcx, 63                              # Then the bit we want to change
  mov    rbp, 1                               # Generate the mask we&apos;ll use to set the correct bit
  shl    rbp, cl
  # We&apos;ll start with the right branch
  or     QWORD PTR [rdx + 8*r13], rbp         # Set the bit
  inc    QWORD PTR [rdx + bitstr_len]         # Increase the bitstring length
  mov    rsi, QWORD PTR [r12 + tree_right]
  call   generate_codebook_recurse
  # Now we move on to the left branch: rbx - left child, r13 - bitstring index, rbp - mask
  not    rbp
  and    QWORD PTR [rdx + 8*r13], rbp
  mov    rsi, QWORD PTR [r12 + tree_left]
  call   generate_codebook_recurse
  dec    QWORD PTR [rdx + bitstr_len]         # Decrease the bitstring length
generate_codebook_recurse_done:
  pop    r13
  pop    r12
  pop    rbp
  ret

# rdi - text
# RET rax - Huffman-tree root (ptr)
generate_tree:
  push   r12
  push   r13
  sub    rsp, 5128                            # 1024 bytes for the char counts, 4 bytes for heap length, 4096 bytes for the heap, 4 byte padding
  mov    r12, rdi                             # Save the original text so it doesn&apos;t get clobbered
  mov    rdi, rsp                             # Zero out the character counts and the heap length
  xor    rsi, rsi
  mov    rdx, 1040
  call   memset
  xor    rax, rax
generate_tree_count_chars:
  mov    al, BYTE PTR [r12]
  test   al, al
  jz     generate_tree_leaves_setup
  inc    DWORD PTR [rsp + 4*rax]
  inc    r12
  jmp    generate_tree_count_chars
generate_tree_leaves_setup:
  mov    r12, 255                             # The loop counter. We can only get here if the &quot;test&quot; on line 301 resulted in a zero so the next jl instruction will do the right thing
generate_tree_leaves:
  jl     generate_tree_branches               # If not then it&apos;s time to generate the branches
  mov    r13d, DWORD PTR [rsp + 4*r12]        # Load the count at the ith position
  test   r13d, r13d                           # And check if it&apos;s zero
  jz     generate_tree_leaves_counters        # If it is we can skip this iteration
  mov    rdi, 1                               # If not, we need to allocate a new leaf node
  mov    rsi, tree_size
  call   calloc
  mov    DWORD PTR [rax + tree_value], r12d   # Save the value and the count to the tree
  mov    DWORD PTR [rax + tree_count], r13d
  lea    rdi, [rsp + counts_size]             # Then push it onto the heap
  mov    rsi, rax
  call   heap_push
generate_tree_leaves_counters:
  dec    r12                                  # Decrement the loop counter and start over
  jmp    generate_tree_leaves
generate_tree_branches:
  cmp    DWORD PTR [rsp + counts_size], 1     # Check if there are still at least two elements in the heap
  jle    generate_tree_done                   # If not, we&apos;re done
  lea    rdi, [rsp + counts_size]             # Get the left child
  call   heap_pop
  mov    r12, rax
  lea    rdi, [rsp + counts_size]             # Get the right child
  call   heap_pop
  mov    r13, rax
  mov    rdi, tree_size                       # Create the new tree node, the pointer to it will be in rax
  call   malloc
  mov    ecx, DWORD PTR [r12 + tree_count]    # The new node&apos;s count: left count + right count
  add    ecx, DWORD PTR [r13 + tree_count]
  mov    QWORD PTR [rax + tree_left], r12     # Save the new node&apos;s fields: left, right, count (leave value unititialized, it shouldn&apos;t be used with branch nodes)
  mov    QWORD PTR [rax + tree_right], r13
  mov    DWORD PTR [rax + tree_count], ecx
  lea    rdi, [rsp + counts_size]             # Add the branch to the heap
  mov    rsi, rax
  call   heap_push
  jmp    generate_tree_branches
generate_tree_done:
  lea    rdi, [rsp + counts_size]             # The tree&apos;s root will be in rax after the pop
  call   heap_pop
  add    rsp, 5128
  pop    r13
  pop    r12
  ret

# rdi - heap ptr
# rsi - tree ptr
heap_push:
  lea    rax, QWORD PTR [rdi + heap_data]     # We load the heap&apos;s data ptr and length to the respective registers
  mov    ecx, DWORD PTR [rdi + heap_len]      # Load the current length
  lea    edx, [ecx + 1]                       # First, calculate the new length (length + 1)
  mov    DWORD PTR [rdi + heap_len], edx      # Then save it
  mov    QWORD PTR [rax + 8*rcx], rsi         # And finally add the new value at the end of the array
heap_push_sift_up:
  test   rcx, rcx                             # Test if we got to the root (index == 0)
  jz     heap_push_done
  lea    rdx, [rcx - 1]                       # Calculate the parent index: (index - 1) / 2
  shr    rdx, 1
  lea    r8, [rax + 8*rcx]                    # Get the pointer to the current and parent elements
  lea    r9, [rax + 8*rdx]
  mov    r10, QWORD PTR [r8]                  # Load the current and the parent elements
  mov    r11, QWORD PTR [r9]
  mov    esi, DWORD PTR [r10 + tree_count]    # Load the current tree&apos;s count
  cmp    DWORD PTR [r11 + tree_count], esi    # If parent count &lt;= current count
  jle    heap_push_done                       # Then we&apos;re done
  mov    QWORD PTR [r8], r11                  # Otherwise swap the two elements
  mov    QWORD PTR [r9], r10
  mov    rcx, rdx
  jmp    heap_push_sift_up
heap_push_done:
  ret

# rdi - heap ptr
# RET rax - tree ptr
heap_pop:
  mov    r8d, DWORD PTR [rdi + heap_len]      # Load the heap&apos;s length
  test   r8d, r8d                             # If it&apos;s 0 then the heap&apos;s empty
  jz     heap_empty
  lea    rdx, [rdi + heap_data]               # Get the heap&apos;s data ptr
  mov    rax, QWORD PTR [rdx]                 # The return value will be the tree&apos;s current root
  lea    r8d, [r8d - 1]                       # Calculate the new length
  mov    DWORD PTR [rdi + heap_len], r8d      # And save it
  mov    rsi, QWORD PTR [rdx + 8*r8]          # Load the element we&apos;re going to swap with the root
  mov    QWORD PTR [rdx], rsi                 # Swap the root and the last element
  mov    QWORD PTR [rdx + 8*r8], rax
  xor    r9, r9                               # The loop index
heap_pop_sift_down:
  mov    rcx, r9                              # Save the target index at the start of the loop
  lea    r10, [r9 + r9 + 1]                   # The left child index
  lea    r11, [r9 + r9 + 2]                   # The right child index
  cmp    r10, r8
  jge    heap_pop_check_right
  mov    rdi, QWORD PTR [rdx + 8*r10]         # Load the left child
  mov    rsi, QWORD PTR [rdx + 8*rcx]         # Load the target
  mov    esi, DWORD PTR [rsi + tree_count]    # Load the target tree count
  cmp    DWORD PTR [rdi + tree_count], esi    # If the left tree count &lt; target tree count
  jge    heap_pop_check_right
  mov    rcx, r10
heap_pop_check_right:
  cmp    r11, r8
  jge    heap_pop_compare_indices
  mov    rdi, QWORD PTR [rdx + 8*r11]         # Load the right child
  mov    rsi, QWORD PTR [rdx + 8*rcx]         # Load the target
  mov    esi, DWORD PTR [rsi + tree_count]    # Load the target tree count
  cmp    DWORD PTR [rdi + tree_count], esi    # If the right tree count &lt; target tree count
  jge    heap_pop_compare_indices
  mov    rcx, r11
heap_pop_compare_indices:
  cmp    r9, rcx                              # If the target index == current index we&apos;re done
  je     heap_pop_done
  mov    rdi, QWORD PTR [rdx + 8*r9]          # Otherwise we swap the values
  mov    rsi, QWORD PTR [rdx + 8*rcx]
  mov    QWORD PTR [rdx + 8*r9], rsi
  mov    QWORD PTR [rdx + 8*rcx], rdi
  mov    r9, rcx
  jmp    heap_pop_sift_down
heap_empty:
  xor    rax, rax                             # Return a null pointer to indicate the heap was empty
heap_pop_done:
  ret

# rdi - codebook start ptr
print_codebook:
  push   rbx
  push   r12
  sub    rsp, 272                             # The bitstring we&apos;re going to print
  mov    r12, rdi
  xor    rbx, rbx                             # Save the loop counter into a register that doesn&apos;t get clobbered
print_codebook_loop:
  cmp    rbx, 255
  jg     print_codebook_done
  lea    rax, [rbx + 4*rbx]                   # We get the codebook entry at the specific index
  lea    r10, [r12 + 8*rax]
  mov    rdx, QWORD PTR [r10 + bitstr_len]    # Load the length of the bitstring
  test   rdx, rdx                             # If it&apos;s zero then the codepoint didn&apos;t exist in the original alphabet, skip
  jz     print_codebook_counters
print_codebook_char:
  mov    BYTE PTR [rsp], bl                   # First, the character we&apos;re printing the code for
  mov    WORD PTR [rsp + 1], 0x203a           # Then &quot;: &quot;
  mov    BYTE PTR [rsp + rdx + 3], 0x00       # At the end add the null terminator
print_codebook_generate_binary:
  dec    rdx
  jl     print_codebook_binary
  mov    r9, rdx                              # Two copies of the loop counter
  mov    rcx, rdx
  shr    r9, 6                                # Calculate the bitstring part we&apos;re going to load
  and    rcx, 63                              # The bit we&apos;re interested in
  mov    rsi, QWORD PTR [r10 + r9]            # One of the 4, 64 bit parts of the bitstring we&apos;re going to print
  shr    rsi, cl                              # Get the relevant bit into the 0th position
  and    rsi, 1                               # Mask the rest of the bits
  add    rsi, &apos;0&apos;                             # Convert it to ASCII
  mov    BYTE PTR [rsp + rdx + 3], sil        # And copy it into the string
  jmp    print_codebook_generate_binary
print_codebook_binary:
  mov    rdi, rsp                             # Print the current bitstring
  call   puts
print_codebook_counters:
  inc    rbx                                  # And go to the next codebook entry
  jmp    print_codebook_loop
print_codebook_done:
  add    rsp, 272
  pop    r12
  pop    rbx
  ret

# rdi - message ptr
# This would run out of stack space for long messages but it will do for now
print_message:
  push   r12
  push   r13
  mov    r12, rdi
  mov    r13, QWORD PTR [rdi]                 # Get the length of the message
  lea    rdi, [r13 + 1]                       # For the length of the string we&apos;ll need an additional the null terminator
  call   malloc
  xor    rdx, rdx
print_message_generate_string:
  cmp    rdx, r13
  jge    print_message_puts
  mov    r8, rdx                              # Get two copies of the current index
  mov    rcx, rdx
  shr    r8, 3                                # We first get the byte we want to print
  mov    r10b, BYTE PTR [r12 + r8 + msg_data]
  and    rcx, 7                               # Then the bit in that byte
  shr    r10, cl
  and    r10, 0x1                             # Mask it so only the bit we&apos;re interested in is visible
  add    r10, &apos;0&apos;                             # Convert it to ASCII
  mov    BYTE PTR [rax + rdx], r10b           # Write it into the printable string
  inc    rdx
  jmp    print_message_generate_string
print_message_puts:
  mov    BYTE PTR [rax + rdx], 0x00           # Write the null terminator
  mov    rdi, rax                             # And print the string
  call   puts
  pop    r13
  pop    r12
  ret

# rdi - tree ptr
free_tree:
  push   rbx
  mov    rbx, rdi
  test   rbx, rbx                             # When the tree ptr we&apos;re trying to free is already null we reached the termination condition
  jz     free_tree_done
  mov    rdi, [rbx + tree_left]               # Otherwise free the left child first
  call   free_tree
  mov    rdi, [rbx + tree_right]              # Then the right child
  call   free_tree
  mov    rdi, rbx                             # And finally, the node itself
  call   free
free_tree_done:
  pop    rbx
  ret
</code></pre>
</div></div></div>

<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../data_compression/data_compression.html" class="navigation navigation-prev " aria-label="Previous page: Data Compression">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../quantum_information/quantum_information.html" class="navigation navigation-next " aria-label="Next page: Quantum Information">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Huffman Encoding","level":"1.17.1","depth":2,"next":{"title":"Quantum Information","level":"1.18","depth":1,"path":"contents/quantum_information/quantum_information.md","ref":"contents/quantum_information/quantum_information.md","articles":[]},"previous":{"title":"Data Compression","level":"1.17","depth":1,"path":"contents/data_compression/data_compression.md","ref":"contents/data_compression/data_compression.md","articles":[{"title":"Huffman Encoding","level":"1.17.1","depth":2,"path":"contents/huffman_encoding/huffman_encoding.md","ref":"contents/huffman_encoding/huffman_encoding.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["fontsettings","mathjax@https://github.com/algorithm-archivists/plugin-mathjax","bibtex-cite","creativecommons","wordcount","api-language-selector@https://github.com/algorithm-archivists/gitbook-plugin-api-language-selector.git","include-codeblock","ga","bulk-redirect"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"api-language-selector":{"languages":[{"lang":"jl","name":"Julia","default":true},{"lang":"bash","name":"Bash"},{"lang":"cs","name":"C#"},{"lang":"cpp","name":"C++"},{"lang":"c","name":"C"},{"lang":"py","name":"Python"},{"lang":"js","name":"JavaScript"},{"lang":"scratch","name":"Scratch"},{"lang":"hs","name":"Haskell"},{"lang":"rs","name":"Rust"},{"lang":"ml","name":"OCaml"},{"lang":"java","name":"Java"},{"lang":"clj","name":"Clojure"},{"lang":"elm","name":"Elm"},{"lang":"LabVIEW","name":"LabVIEW"},{"lang":"d","name":"D"},{"lang":"go","name":"Go"},{"lang":"swift","name":"Swift"},{"lang":"racket","name":"Racket"},{"lang":"m","name":"Matlab"},{"lang":"r","name":"R"},{"lang":"ti83b","name":"TI-83 Basic"},{"lang":"lua","name":"Lua"},{"lang":"crystal","name":"Crystal"},{"lang":"php","name":"PHP"},{"lang":"lisp","name":"Lisp"},{"lang":"nim","name":"Nim"},{"lang":"asm-x64","name":"X86-64 Assembly"},{"lang":"f90","name":"Fortran90"},{"lang":"factor","name":"Factor"},{"lang":"ws","name":"Whitespace"},{"lang":"scala","name":"Scala"},{"lang":"emojic","name":"Emojicode"},{"lang":"lolcode","name":"LOLCODE"}]},"wordcount":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"family":"sans","size":2,"theme":"white"},"highlight":{},"bulk-redirect":{"basepath":"/","redirectsFile":"redirects.json"},"bibtex-cite":{},"creativecommons":{},"mathjax":{"forceSVG":false,"version":"2.6.1"},"ga":{"configuration":"auto","token":"UA-118252470-1"},"include-codeblock":{"check":false,"edit":false,"fixlang":true,"lang":"","template":"default","theme":"chrome","unindent":true},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","lunr":{"maxIndexSize":1000000000},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"bibCount":0,"variables":{},"bib":[{"citationKey":"CT1965","entryType":"ARTICLE","entryTags":{"TITLE":"An algorithm for the machine calculation of complex Fourier series","AUTHOR":"Cooley, James W and Tukey, John W","JOURNAL":"Mathematics of computation","VOLUME":"19","NUMBER":"90","PAGES":"297--301","YEAR":"1965","PUBLISHER":"JSTOR"}},{"citationKey":"JM1973","entryType":"ARTICLE","entryTags":{"TITLE":"On the identification of the convex hull of a finite set of points in the plane","AUTHOR":"Jarvis, Ray A","JOURNAL":"Information processing letters","VOLUME":"2","NUMBER":"1","PAGES":"18--21","YEAR":"1973","PUBLISHER":"Elsevier"}},{"citationKey":"GS1972","entryType":"ARTICLE","entryTags":{"TITLE":"An efficient algorithm for determining the convex hull of a finite planar set","AUTHOR":"Graham, Ronald L","JOURNAL":"Information processing letters","VOLUME":"1","NUMBER":"4","PAGES":"132--133","YEAR":"1972","PUBLISHER":"Elsevier"}}],"gitbook":"3.x.x"},"file":{"path":"contents/huffman_encoding/huffman_encoding.md","mtime":"2018-10-20T05:34:51.280Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-20T05:36:31.258Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-api-language-selector/api-language-selector.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    

    </body>
</html>

